
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IOC与DI,Decorator,reflect Matedata - wumi&#39;s blog</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="wumi,"> 
    <meta name="description" content="wumi&#39;s blog,
内容来自互联网, 仅用于个人学习记忆

IoCIoC（Inversion of Control）控制反转,是面向对象编程中的一种设计原则，用来降低计算机代码之间的耦合度

在传统面向对象的编码过程,"> 
    <meta name="author" content="5mi"> 
    <link rel="alternative" href="atom.xml" title="wumi&#39;s blog" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

    <link rel="stylesheet" href="//at.alicdn.com/t/font_2511899_nhreworgr7.css">
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">wumi&#39;s blog</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="/"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">IOC与DI,Decorator,reflect Matedata</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">IOC与DI,Decorator,reflect Matedata</h1>
        <div class="stuff">
            <span>十月 10, 2021</span>
            
                <!-- 不蒜子统计 -->
                <span id="busuanzi_container_page_pv" style='display:none'>
                      <i class="iconfont-for-blog icon-for-blogbook"></i> <span id="busuanzi_value_page_pv"></span>
                </span>
            
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li></ul>


        </div>
        <div class="content markdown">
            <blockquote>
<p>内容来自互联网, 仅用于个人学习记忆</p>
</blockquote>
<h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><p>IoC（Inversion of Control）控制反转,是面向对象编程中的一种设计原则，用来降低计算机代码之间的耦合度</p>
<blockquote>
<p>在传统面向对象的编码过程中，当类与类之间存在依赖关系时，通常会直接在类的内部创建依赖对象，这样就导致类与类之间形成了耦合，依赖关系越复杂，耦合程度就会越高，而耦合度高的代码会非常难以进行修改和单元测试。而 IoC 则是专门提供一个容器进行依赖对象的创建和查找，将对依赖对象的控制权由类内部交到容器这里，这样就实现了类与类的解耦，保证所有的类都是可以灵活修改</p>
</blockquote>
<h4 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h4><p>在不使用 IoC 的情况下，我们很容易写出来这样的代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modB.ts</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  p: <span class="built_in">number</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">p</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.p = p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">&quot;./modA&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; B &#125; <span class="keyword">from</span> <span class="string">&quot;./modB&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  a: A;</span><br><span class="line">  b: B;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="built_in">this</span>.b = <span class="keyword">new</span> B(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>C</code>类需要依赖<code>A</code>,<code>B</code>类 与其耦合, 当随着项目的迭代, 依赖关系发生变化,或依赖项<code>A</code>,<code>B</code>初始化参数变化时, 这种依赖关系将变得难以维护</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">&quot;./modA&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; B &#125; <span class="keyword">from</span> <span class="string">&quot;./modB&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  a: A;</span><br><span class="line">  b: B;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">    <span class="built_in">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B(<span class="string">&quot;what ever&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C(a, b);</span><br></pre></td></tr></table></figure>

<p>实际上对于<code>C</code>类型实例化而言,并不在乎<code>B</code>实例化的参数, 稍加修改只需要通过<code>A</code>,<code>B</code>的实例就可进行构造, 这样就能体现出类与类之间的解耦</p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><blockquote>
<p>虽然我们实现了解耦，但我们仍需要自己初始化所有的类，并以构造函数参数的形式进行传递。如果存在一个全局的容器，里面预先注册好了我们所需对象的类定义以及初始化参数，每个对象有一个唯一的 key。那么当我们需要用到某个对象时，我们只需要告诉容器它对应的 key，就可以直接从容器中取出实例化好的对象，开发者就不用再关心对象的实例化过程，也不需要将依赖对象作为构造函数的参数在依赖链路上传递, 也就是说，我们的容器必须具体两个功能，<strong>实例的注册和获取</strong></p>
</blockquote>
<p>即我们可以构造一个容器,维护未来需要使用的类及其对照关系,当需要具体类型的实例时, 通过对照关系可以找到对应的类, 并在容器中直接初始化</p>
<blockquote>
<p>再举个栗子，当我们想要处对象时，会上 Soul、Summer、陌陌…等等去一个个找，找哪种的与怎么找是由我自己决定的，这叫 <strong>控制正转</strong>。现在我觉得有点麻烦，直接把自己的介绍上传到世纪佳缘，如果有人看上我了，就会主动向我发起聊天，这叫 <strong>控制反转</strong></p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">&quot;./modA&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; B &#125; <span class="keyword">from</span> <span class="string">&quot;./modB&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  a: A;</span><br><span class="line">  b: B;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 手动从容器中获取实例</span></span><br><span class="line">    <span class="built_in">this</span>.a = container.get(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.b = container.get(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="keyword">new</span> Container();</span><br><span class="line"><span class="comment">// 手动向容器注册类型</span></span><br><span class="line">container.bind(<span class="string">&quot;a&quot;</span>, A);</span><br><span class="line">container.bind(<span class="string">&quot;b&quot;</span>, B, [<span class="string">&quot;what ever&quot;</span>]);</span><br><span class="line">container.bind(<span class="string">&quot;c&quot;</span>, C);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从容器中取出c</span></span><br><span class="line"><span class="keyword">const</span> c = container.get(<span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>到此为止, 虽然容器完成了类与类的解耦, 但容器的初始化及各类型的注册看上去还是很繁琐的, 如果这部分可以通过封装进框架自动进行, 并且在类实例化时无需手动指定, 而可以直接自动拿到所需实例, 这样就可以更专注于内部逻辑的开发, 及实现依赖注入</p>
<h3 id="DI（Dependency-Injection）依赖注入"><a href="#DI（Dependency-Injection）依赖注入" class="headerlink" title="DI（Dependency Injection）依赖注入"></a>DI（Dependency Injection）依赖注入</h3><p>IoC 是一种思想, 而 DI 是其一种技术实现, 即将依赖注入给调用方,而无需调用发主动获取, 需要解决一下问题</p>
<ul>
<li>程序启动时,所有类型会在容器中自动注册</li>
<li>实例化时类型所需的对象的自动注入, 无需在构造函数中指定</li>
</ul>
<p>而这些即可通过 <code>TS装饰器</code> 结合 <code>Reflect Metadata</code>实现</p>
<h4 id="TS-Decorator"><a href="#TS-Decorator" class="headerlink" title="TS Decorator"></a>TS Decorator</h4><blockquote>
<p>首先在<code>tsconfig.json</code>中设置<code>experimentalDecorators</code>与<code>emitDecoratorMetadata</code>为<code>true</code></p>
</blockquote>
<h5 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addProp</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  <span class="title">constructor</span>.<span class="title">prototype</span>.<span class="title">sayhi</span> = &quot;<span class="title">hi</span>&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@addProp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> P();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.sayhi); <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>

<p>对于类装饰器来说 入参为 此 Class 即 <strong>构造函数</strong></p>
<h5 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h5><p>方法装饰器的入参为 <strong>类的原型对象</strong> <strong>属性名</strong> 以及 **属性描述符(descriptor)**，其属性描述符包含<code>writable</code> <code>enumerable</code> <code>configurable</code> <code>value</code> ，我们可以在这里去配置其相关信息 类似<code>Object.defineProperty()</code></p>
<blockquote>
<ol>
<li>Either the constructor function of the class for a static member, or the prototype of the class for an instance member.</li>
<li>The name of the member.</li>
<li>The Property Descriptor for the member.</li>
</ol>
</blockquote>
<blockquote>
<p>注意，对于静态成员来说，首个参数会是类的构造函数。而对于实例成员（比如下面的例子），则是类的原型对象</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addProps</span>(<span class="params"></span>): <span class="title">MethodDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, propertyKey, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// A.prototype</span></span><br><span class="line">    <span class="built_in">console</span>.log(target);</span><br><span class="line">    <span class="built_in">console</span>.log(propertyKey);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(descriptor));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="meta">@addProps</span>()</span><br><span class="line">  <span class="function"><span class="title">sayhi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hi~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h5><p>类似于方法装饰器，但它的入参少了属性描述符。原因则是目前没有方法在定义原型对象成员同时去描述一个实例的属性（创建描述符）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addProp</span>(<span class="params">target, propertyKey</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// A.prototype</span></span><br><span class="line">  <span class="built_in">console</span>.log(target);</span><br><span class="line">  <span class="comment">// 装饰的属性</span></span><br><span class="line">  <span class="built_in">console</span>.log(propertyKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="meta">@addProp</span></span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h5><p>参数装饰器的入参首要两位与属性装饰器相同，第三个参数则是参数在当前函数参数中的<strong>索引</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paramDeco</span>(<span class="params">params?: <span class="built_in">any</span></span>): <span class="title">ParameterDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, propertyKey, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target);</span><br><span class="line">    <span class="built_in">console</span>.log(propertyKey);</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">    target.constructor.prototype.fromParamDeco = <span class="string">&quot;呀呼！&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">someMethod</span>(<span class="params"><span class="meta">@paramDeco</span>() param: <span class="built_in">any</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;param&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> B().someMethod(<span class="string">&quot;okok&quot;</span>);</span><br><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line"><span class="built_in">console</span>.log(B.prototype.fromParamDeco);</span><br></pre></td></tr></table></figure>

<h5 id="多个装饰器声明"><a href="#多个装饰器声明" class="headerlink" title="多个装饰器声明"></a>多个装饰器声明</h5><blockquote>
<p>As such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:</p>
<ol>
<li> The expressions for each decorator are evaluated top-to-bottom.</li>
<li> The results are then called as functions from bottom-to-top.</li>
</ol>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;first(): factory evaluated&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    propertyKey: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    descriptor: PropertyDescriptor</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;first(): called&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;second(): factory evaluated&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    propertyKey: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    descriptor: PropertyDescriptor</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;second(): called&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> </span>&#123;</span><br><span class="line">  <span class="meta">@first</span>()</span><br><span class="line">  <span class="meta">@second</span>()</span><br><span class="line">  <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Which would print this output to the console:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first(): factory evaluated</span><br><span class="line">second(): factory evaluated</span><br><span class="line">second(): called</span><br><span class="line">first(): called</span><br></pre></td></tr></table></figure>

<blockquote>
<p>There is a well defined order to how decorators applied to various declarations inside of a class are applied:</p>
<ol>
<li> Parameter Decorators(参数装饰器), followed by Method(方法装饰器), Accessor(如属性 getter 访问符装饰器), or Property Decorators(属性装饰器) are applied for each instance member.</li>
<li> Parameter Decorators, followed by Method, Accessor, or Property Decorators are applied for each static member.</li>
<li> Parameter Decorators are applied for the constructor.</li>
<li> Class Decorators are applied for the class.</li>
</ol>
</blockquote>
<h4 id="Reflect-Metadata"><a href="#Reflect-Metadata" class="headerlink" title="Reflect Metadata"></a>Reflect Metadata</h4><p>Reflect Metadata 是属于 ES7 的一个提案，其主要作用是在声明时去读写元数据</p>
<p>为类或类属性添加了元数据后，构造函数的原型（或是构造函数，根据静态成员还是实例成员决定）会具有<code>[[Metadata]]</code>属性，该属性内部包含一个<code>Map</code>结构，键为属性键，值为元数据键值对。</p>
<h5 id="metadata-方法"><a href="#metadata-方法" class="headerlink" title="metadata 方法"></a>metadata 方法</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">metadataKey</span></span> - 元数据入口的key</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>metadataValue 元数据入口的value</span></span><br><span class="line"><span class="comment">* <span class="doctag">@returns </span>装饰器函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">metadata</span>(<span class="params">metadataKey: <span class="built_in">any</span>, metadataValue: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    (target: <span class="built_in">Function</span>): <span class="built_in">void</span>;</span><br><span class="line">    (target: <span class="built_in">Object</span>, <span class="attr">propertyKey</span>: <span class="built_in">string</span> | symbol): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nameSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;veloma&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类元数据</span></span><br><span class="line"><span class="meta">@Reflect</span>.metadata(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;class&#x27;</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaDataClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例属性元数据</span></span><br><span class="line">    <span class="meta">@Reflect</span>.metadata(nameSymbol, <span class="string">&#x27;nihao&#x27;</span>)</span><br><span class="line">    <span class="keyword">public</span> name = <span class="string">&#x27;origin&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例方法元数据</span></span><br><span class="line">    <span class="meta">@Reflect</span>.metadata(<span class="string">&#x27;getName&#x27;</span>, <span class="string">&#x27;getName&#x27;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法元数据</span></span><br><span class="line">    <span class="meta">@Reflect</span>.metadata(<span class="string">&#x27;static&#x27;</span>, <span class="string">&#x27;static&#x27;</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">staticMethod</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建元数据类的实例</span></span><br><span class="line"><span class="keyword">const</span> metadataInstance = <span class="keyword">new</span> MetaDataClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取MetaDataClass的name元数据</span></span><br><span class="line"><span class="keyword">const</span> value = <span class="built_in">Reflect</span>.getMetadata(<span class="string">&#x27;name&#x27;</span>, MetaDataClass); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 获取实例中name属性的nameSymbol元数据</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="built_in">Reflect</span>.getMetadata(nameSymbol, metadataInstance, <span class="string">&#x27;name&#x27;</span>); <span class="comment">// nihao</span></span><br><span class="line"><span class="comment">// 获取实例中getName属性的getName元数据</span></span><br><span class="line"><span class="keyword">const</span> methodVal = <span class="built_in">Reflect</span>.getMetadata(<span class="string">&#x27;getName&#x27;</span>, metadataInstance, <span class="string">&#x27;getName&#x27;</span>); <span class="comment">// getName</span></span><br><span class="line"><span class="comment">// 获取元数据类的staticMethod属性的static元数据</span></span><br><span class="line"><span class="keyword">const</span> staticVal = <span class="built_in">Reflect</span>.getMetadata(<span class="string">&#x27;static&#x27;</span>, MetaDataClass, <span class="string">&#x27;staticMethod&#x27;</span>); <span class="comment">// static</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(value, name, methodVal, staticVal); <span class="comment">// undefined nihao getName static</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们注意到，注入在<strong>静态成员</strong> 如类上及静态属性的元数据在取出时<code>target</code>为这个<strong>类</strong>，而注入在<strong>实例成员</strong> 如方法,属性上的元数据在取出时<code>target</code>则为<strong>实例</strong>。原因其实我们实际上在上面的装饰器执行顺序提到了，这是由于<strong>注入在方法、属性、参数上的元数据实际上是被添加在了实例对应的位置上，因此需要实例化才能取出</strong></p>
<h5 id="defineMetadata-方法"><a href="#defineMetadata-方法" class="headerlink" title="defineMetadata 方法"></a>defineMetadata 方法</h5><p>该方法是<code>metadata</code>的定义版本, 也就是非<code>@</code>版本, 会多传一个参数<code>target</code>, 表示待装饰的对象</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">metadataKey</span></span> - 设置或获取时的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">metadataValue</span></span> - 元数据内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">target</span></span> - 待装饰的target</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">targetKey</span></span> - target的property</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineMetadata</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  metadataKey: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  metadataValue: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  target: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetKey: <span class="built_in">string</span> | symbol</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span></span>;</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefineMetadata</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">staticMethod</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> staticProperty = <span class="string">&quot;static&quot;</span>;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">type</span> = <span class="string">&quot;type&quot;</span>;</span><br><span class="line"><span class="comment">// 给DefineMetadata设置元数据type, 值为class</span></span><br><span class="line"><span class="built_in">Reflect</span>.defineMetadata(<span class="keyword">type</span>, <span class="string">&quot;class&quot;</span>, DefineMetadata);</span><br><span class="line"><span class="comment">// 给DefineMetadata.staticMethod设置元数据type, 值为staticMethod</span></span><br><span class="line"><span class="built_in">Reflect</span>.defineMetadata(<span class="keyword">type</span>, <span class="string">&quot;staticMethod&quot;</span>, DefineMetadata.staticMethod);</span><br><span class="line"><span class="comment">// 给DefineMeatadata.prorotype.getName设置元数据type, 值为method</span></span><br><span class="line"><span class="built_in">Reflect</span>.defineMetadata(<span class="keyword">type</span>, <span class="string">&quot;method&quot;</span>, DefineMetadata.prorotype.getName);</span><br><span class="line"><span class="comment">// 给DefineMetadata的staticProperty属性设置元数据type, 值为staticProperty</span></span><br><span class="line"><span class="built_in">Reflect</span>.defineMetadata(</span><br><span class="line">  <span class="keyword">type</span>,</span><br><span class="line">  <span class="string">&quot;staticProperty&quot;</span>,</span><br><span class="line">  DefineMetadata,</span><br><span class="line">  <span class="string">&quot;staticProperty&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取DefineMetadata身上的type元数据</span></span><br><span class="line"><span class="keyword">const</span> t1 = <span class="built_in">Reflect</span>.getMetadata(<span class="keyword">type</span>, DefineMetadata); <span class="comment">// class</span></span><br><span class="line"><span class="comment">// 获取DefineMetadata.staticMethod身上的type元数据</span></span><br><span class="line"><span class="keyword">const</span> t2 = <span class="built_in">Reflect</span>.getMetadata(<span class="keyword">type</span>, DefineMetadata.staticMethod); <span class="comment">// staticMethod</span></span><br><span class="line"><span class="comment">// 获取DefineMetadata.prototype.getName身上的type元数据</span></span><br><span class="line"><span class="keyword">const</span> t3 = <span class="built_in">Reflect</span>.getMetadata(<span class="keyword">type</span>, DefineMetadata.prototype.getName); <span class="comment">// method</span></span><br><span class="line"><span class="comment">// 获取DefineMetadata上staticProperty属性的type元数据</span></span><br><span class="line"><span class="keyword">const</span> t4 = <span class="built_in">Reflect</span>.getMetadata(<span class="keyword">type</span>, DefineMetadata, <span class="string">&quot;staticProperty&quot;</span>); <span class="comment">// staticProperty</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(t1, t2, t3, t4); <span class="comment">// class staticMethod method staticProperty</span></span><br></pre></td></tr></table></figure>

<p>首先 npm 安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i reflect-metadata --save</span><br></pre></td></tr></table></figure>

<p>When enabled, as long as the reflect-metadata library has been imported, additional design-time type information will be exposed at runtime.</p>
<p>We can see this in action in the following example:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect-metadata&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> x: <span class="built_in">number</span>, <span class="keyword">public</span> y: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _start: Point;</span><br><span class="line">  <span class="keyword">private</span> _end: Point;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@validate</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title">start</span>(<span class="params">value: Point</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._start = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">start</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._start;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@validate</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title">end</span>(<span class="params">value: Point</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._end = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">end</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._end;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  propertyKey: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  descriptor: TypedPropertyDescriptor&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> set = descriptor.set!;</span><br><span class="line"></span><br><span class="line">  descriptor.set = <span class="function"><span class="keyword">function</span> (<span class="params">value: T</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">type</span> = <span class="built_in">Reflect</span>.getMetadata(<span class="string">&quot;design:type&quot;</span>, target, propertyKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(value <span class="keyword">instanceof</span> <span class="keyword">type</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">        <span class="string">`Invalid type, got <span class="subst">$&#123;<span class="keyword">typeof</span> value&#125;</span> not <span class="subst">$&#123;<span class="keyword">type</span>.name&#125;</span>.`</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set.call(<span class="built_in">this</span>, value);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> line = <span class="keyword">new</span> Line();</span><br><span class="line">line.start = <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line"><span class="comment">// line.end = &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fails at runtime with:</span></span><br><span class="line"><span class="comment">// &gt; Invalid type, got object not Point</span></span><br></pre></td></tr></table></figure>

<p>The TypeScript compiler will inject design-time type information using the @Reflect.metadata decorator. You could consider it the equivalent of the following TypeScript:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _start: Point;</span><br><span class="line">  <span class="keyword">private</span> _end: Point;</span><br><span class="line">  <span class="meta">@validate</span></span><br><span class="line">  <span class="meta">@Reflect</span>.metadata(<span class="string">&quot;design:type&quot;</span>, Point)</span><br><span class="line">  <span class="keyword">set</span> <span class="title">start</span>(<span class="params">value: Point</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._start = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">start</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._start;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@validate</span></span><br><span class="line">  <span class="meta">@Reflect</span>.metadata(<span class="string">&quot;design:type&quot;</span>, Point)</span><br><span class="line">  <span class="keyword">set</span> <span class="title">end</span>(<span class="params">value: Point</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._end = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">end</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._end;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>design:type</code> 即是 TS 的内置元数据，你可以理解为 TS 在编译前还手动执行了<code>@Reflect.metadata(&quot;design:type&quot;, Point)</code>。TS 还内置了 <strong><code>design:paramtypes</code>（获取目标参数类型）与<code>design:returntype</code>（获取方法返回值类型）</strong> 这两种元数据字段来提供帮助。但有一点需要注意，即使对于基本类型，这些元数据也返回对应的包装类型，如<code>number -&gt; [Function: Number]</code></p>
<h3 id="DI-Provider"><a href="#DI-Provider" class="headerlink" title="DI Provider"></a>DI Provider</h3><p>回到我们刚刚提到的问题，我们需要在应用启动的时候自动对所有类进行定义和参数的注册，问题是并不是所有的类都需要注册到容器中，我们并不清楚哪些类需要注册的，同时也不清楚需要注册的类，它的初始化参数是什么样的。</p>
<p>这里就可以引入元数据来解决这个问题，只要在定义的时候为这个类的元数据添加特殊的标记，就可以在扫描的时候识别出来。按照这个思路，我们先来实现一个装饰器标记需要注册的类，这个装饰器可以命名 Provider，代表它将会作为提供者给其他类进行消费。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// provider.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect-metadata&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CLASS_KEY = <span class="string">&quot;ioc:tagged_class&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Provider</span>(<span class="params">identifier: <span class="built_in">string</span>, args?: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Reflect</span>.defineMetadata(</span><br><span class="line">      CLASS_KEY,</span><br><span class="line">      &#123;</span><br><span class="line">        id: identifier,</span><br><span class="line">        args: args || [],</span><br><span class="line">      &#125;,</span><br><span class="line">      target</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可使用<code>Provider</code>对类 进行标记, 为了之后将其自动注册到容器中</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modB.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&quot;provider&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Provider</span>(<span class="string">&quot;b&quot;</span>, [<span class="number">10</span>])</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  p: <span class="built_in">number</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">p: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.p = p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动注册到容器中的思路则是在启动的时候对所有文件进行扫描，获取每个文件导出的类，然后根据元数据进行绑定。简单起见，我们假设项目目录只有一级文件，实现如下:</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">&quot;fs&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CLASS_KEY &#125; <span class="keyword">from</span> <span class="string">&quot;./provider&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// container 为全局的 IoC 容器</span></span><br><span class="line">  <span class="keyword">const</span> list = fs.readdirSync(<span class="string">&quot;./&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> file <span class="keyword">of</span> list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/\.ts$/</span>.test(file)) &#123;</span><br><span class="line">      <span class="comment">// 扫描 ts 文件</span></span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">exports</span> = <span class="built_in">require</span>(<span class="string">`./<span class="subst">$&#123;file&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> m <span class="keyword">in</span> <span class="built_in">exports</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">module</span> = <span class="built_in">exports</span>[m];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> metadata = <span class="built_in">Reflect</span>.getMetadata(CLASS_KEY, <span class="built_in">module</span>);</span><br><span class="line">          <span class="comment">// 注册实例</span></span><br><span class="line">          <span class="keyword">if</span> (metadata) &#123;</span><br><span class="line">            container.bind(metadata.id, <span class="built_in">module</span>, metadata.args);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需在项目启动时运行<code>load</code>,就可将声明时被<code>Provider</code>装饰的类,自动注册到容器中</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Container &#125; <span class="keyword">from</span> <span class="string">&quot;./container&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; load &#125; <span class="keyword">from</span> <span class="string">&quot;./load&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 IOC 容器，扫描文件</span></span><br><span class="line"><span class="keyword">const</span> container = <span class="keyword">new</span> Container();</span><br><span class="line">load(container);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(container.get(<span class="string">&quot;b&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="DI-Inject"><a href="#DI-Inject" class="headerlink" title="DI Inject"></a>DI Inject</h3><p>上文提及</p>
<blockquote>
<ul>
<li>程序启动时,所有类型会在容器中自动注册</li>
<li>实例化时类型所需的对象的自动注入, 无需在构造函数中指定</li>
</ul>
</blockquote>
<p>第一个问题解决后,再来看第二个问题,我们已经将所有需要注册的类都放入了 IoC 容器，那么，当我们需要用到某个类时，在获取这个类的实例时可以递归遍历类上的属性，并从 IoC 容器中取出相应的对象并进行赋值，即可完成依赖的注入</p>
<p>那么，又是类似的问题，如何区分哪些属性需要注入？同样，我们可以使用元数据来解决。只要定义一个装饰器，以此来标记哪些属性需要注入即可，这个装饰器命名为 <code>Inject</code>，代表该属性需要注入依赖。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inject.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect-metadata&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> PROPS_KEY = <span class="string">&quot;ioc:inject_props&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Inject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> annotationTarget = target.constructor;</span><br><span class="line">    <span class="keyword">let</span> props = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Reflect</span>.hasOwnMetadata(PROPS_KEY, annotationTarget)) &#123;</span><br><span class="line">      props = <span class="built_in">Reflect</span>.getMetadata(PROPS_KEY, annotationTarget);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    props[targetKey] = &#123;</span><br><span class="line">      value: targetKey,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Reflect</span>.defineMetadata(PROPS_KEY, props, annotationTarget);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这里我们虽然是对属性进行修饰，但实际元数据是要定义在类上，以维护该类需要注入的属性列表，因此我们必须取 <code>target.constructor</code> 作为要操作的 <code>target</code>。另外，为了方便起见，这里直接用了属性名（<code>targetKey</code>）作为从 IoC 容器中实例对应的 key。</p>
<p>然后，我们需要修改 IoC 容器的 get 方法，递归注入所有属性：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// container.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; PROPS_KEY &#125; <span class="keyword">from</span> <span class="string">&#x27;./inject&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    bindMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">bind</span>(<span class="params">identifier: <span class="built_in">string</span>, clazz: <span class="built_in">any</span>, constructorArgs?: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bindMap.set(identifier, &#123;</span><br><span class="line">            clazz,</span><br><span class="line">            <span class="title">constructorArgs</span>: <span class="title">constructorArgs</span> || []</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get&lt;T&gt;(identifier: <span class="built_in">string</span>): T &#123;</span><br><span class="line">        <span class="keyword">const</span> target = <span class="built_in">this</span>.bindMap.get(identifier);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123; clazz, <span class="title">constructorArgs</span> &#125; = <span class="title">target</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> props = <span class="built_in">Reflect</span>.getMetadata(PROPS_KEY, clazz);</span><br><span class="line">        <span class="keyword">const</span> inst = <span class="built_in">Reflect</span>.construct(clazz, <span class="title">constructorArgs</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> props) &#123;</span><br><span class="line">            <span class="keyword">const</span> identifier = props[prop].value;</span><br><span class="line">            <span class="comment">// 递归获取注入的对象</span></span><br><span class="line">            inst[ prop ] = <span class="built_in">this</span>.get(identifier);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用的时候，用 <code>Inject</code> 对属性(依赖的实例)进行装饰即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&#x27;provider&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Provider</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Inject</span>()</span><br><span class="line">  a: A;</span><br><span class="line">  <span class="meta">@Inject</span>()</span><br><span class="line">  b: B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终代码则有: </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Container &#125; <span class="keyword">from</span> <span class="string">&quot;./container&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; load &#125; <span class="keyword">from</span> <span class="string">&quot;./load&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 IOC 容器，扫描文件</span></span><br><span class="line"><span class="keyword">const</span> container = <span class="keyword">new</span> Container();</span><br><span class="line">load(container);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get 时扫描元数据获取依赖的属性, 将递归注入实例对象</span></span><br><span class="line"><span class="built_in">console</span>.log(container.get(<span class="string">&quot;c&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>则可理解为 <code>Provider</code>装饰的类将自动注册到容器中, <code>Inject</code>装饰的属性 则为依赖的类的实例, 当从容器get一个类型的实例时,会将该类型所依赖实例自动注入到产出的实例中</p>
<p>文章来自:</p>
<p><a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/decorators.html#introduction">ts decorators</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6859314697204662279">走近 MidwayJS：初识 TS 装饰器与 IoC 机制</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6898882861277904910">如何基于 TypeScript 实现控制反转</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6972421467552088072">Reflect Metadata(元数据)学习笔记</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/rbuckton/reflect-metadata#metadata-reflection-api">metadata-reflection-api</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903970289238030">有趣的装饰器：使用 Reflect Metadata 实践依赖注入</a></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='/music/Saito - 愛撫 「Saito Ｘ ＡＰＯ」.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='/music/坂本龍一 - Merry Christmas Mr.Lawrence.mp3'></li>
                        
                    
                        
                            <li title='2' data-url='/music/茶太 (ちゃた) - 晴れ→恋心 (晴朗→恋心) [mqms2].mp3'></li>
                        
                    
                        
                            <li title='3' data-url='/music/光宗信吉 - Lost in Love.mp3'></li>
                        
                    
                        
                            <li title='4' data-url='/music/光宗信吉 - 恋ってもどかしい.mp3'></li>
                        
                    
                        
                            <li title='5' data-url='/music/菅野祐悟 - 美春の告白.mp3'></li>
                        
                    
                        
                            <li title='6' data-url='/music/麻枝准 - 夏影.mp3'></li>
                        
                    
                        
                            <li title='7' data-url='/music/山冈晃 (AKIRA YAMAOKA) - Promise [mqms2].mp3'></li>
                        
                    
                        
                            <li title='8' data-url='/music/上松範康 - 運命-SADAME-.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <!-- <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div> -->


    </div>
    
</div>


    </div>
</div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"debug":false,"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":"ture"},"react":{"opacity":0.9},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>
<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML.js"></script>
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
