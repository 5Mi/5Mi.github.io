<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>firsttime</title>
    <url>/2016/08/17/firsttime/</url>
    <content><![CDATA[<p>尝试下hexo搭博客,感觉还是github下用issue更快一点儿?嘛,用hexo倒是可以有好看的主题来用</p>
<p>博客坚持写下去的可能性对我来说还未知= =</p>
<p>有机会再体验下hexo吧</p>
<p><a href="https://github.com/5Mi/wumi_blog">github下用issue没事儿会记点儿东西</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>certbot配置nginx https</title>
    <url>/2021/04/26/certbot%E9%85%8D%E7%BD%AEnginx-https/</url>
    <content><![CDATA[<p>还记得去年服务器备案申请域名折腾了两三天, 又是拍照又是上传身份证的, 记得当时回访的网警还问我网站内容做好上线了吗? 我答没有, 他便和我说那等我弄好了再申请下, 当时想着只是做技术上的尝试也没在意, 这事放了好久, 前几天发现域名居然通过了,备案也成功了, 这就可以折腾起来了</p>
<p>首先nginx配置我推荐用这个线上的<a href="https://www.digitalocean.com/community/tools/nginx">NGINXConfig</a>,可以根据预设或自定义一步步的配置nginx,完成后可以直接拷贝或下载配置</p>
<p><img src="nginx1.png" alt="nginx1"></p>
<p>我这边是docker启动的nginx,所以一定要注意本地挂载目录和nginx配置中要对应一致,由于对生成配置目录的不熟悉导致我这里频繁改了好多次</p>
<p>接下来就是通过certbot配置letsencrypt证书了, 这里要注意的是首次启动先将nginx设置为<code>http</code>即可,certbot生成证书时要先能访问此服务, 通过certbot的webroot来获取证书,certbot会根据<code>-w</code>参数的配置指定路径,之后在服务的这个路径下放置校验文件,后续会向服务的路径(<code>-w</code>设置的)发起请求来校验文件,服务可访问且校验通过后才能得到证书, 所以对应nginx添加配置,注意<code>/var/www/_letsencrypt</code>多处要配置一致</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nginx</span></span><br><span class="line"><span class="comment"># ACME-challenge</span></span><br><span class="line"><span class="string">location</span> <span class="string">^~</span> <span class="string">/.well-known/acme-challenge/</span> &#123;</span><br><span class="line">    <span class="string">root</span> <span class="string">/var/www/_letsencrypt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于nginx和certbot服务都是docker 容器, 所以对应的校验路径要两容器都能读写访问,所以<strong>要注意把校验路径配置一致,挂载到本地同一目录</strong>, 此处我将<code>/var/www/_letsencrypt</code>统一挂载到<code>/home/nginx</code>,nginx的本地挂载目录下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># certbot的docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span>      </span><br><span class="line">  <span class="attr">docker_certbot:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">certbot/certbot</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">certbot</span></span><br><span class="line">    <span class="attr">volumes:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/letsencrypt:/etc/letsencrypt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/lib/letsencrypt:/var/lib/letsencrypt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/nginx:/var/www/_letsencrypt</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">certonly</span> <span class="string">--webroot</span> <span class="string">-d</span> <span class="string">www.mimimimimi.top</span> <span class="string">--email</span> <span class="number">393223434</span><span class="string">@qq.com</span> <span class="string">-w</span> <span class="string">/var/www/_letsencrypt</span> <span class="string">-n</span> <span class="string">--agree-tos</span> <span class="string">--force-renewal</span></span><br></pre></td></tr></table></figure>

<p>certbot得到证书后,nginx同样需要可读, 所以将两服务得证书目录统一挂载到本地同目录<code>/etc/letsencrypt</code>下,此时再将nginx配置成<code>https</code>,注意nginx配置中对应ssl部分要做相应修改,目录一致 例如:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SSL</span></span><br><span class="line"><span class="string">ssl_certificate</span>         <span class="string">/etc/letsencrypt/live/mimimimimi.top/fullchain.pem;</span></span><br><span class="line"><span class="string">ssl_certificate_key</span>     <span class="string">/etc/letsencrypt/live/mimimimimi.top/privkey.pem;</span></span><br><span class="line"><span class="string">ssl_trusted_certificate</span> <span class="string">/etc/letsencrypt/live/mimimimimi.top/chain.pem;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nginx 的 docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span>    <span class="comment"># 指定 docker-compose.yml 文件的写法格式</span></span><br><span class="line"><span class="attr">services:</span>       <span class="comment"># 多个容器集合</span></span><br><span class="line">  <span class="attr">docker_nginx:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">root</span>  <span class="comment"># 为了避免一些权限问题 在这我使用了root</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span> <span class="comment"># 重启方式</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span> <span class="comment"># 容器名称</span></span><br><span class="line">    <span class="attr">ports:</span>      <span class="comment"># 对外暴露的端口定义</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;80:80&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;443:443&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span>    <span class="comment"># 卷挂载路径 防止挂载覆盖</span></span><br><span class="line">      <span class="comment"># /home/nginx:/etc/nginx 存在默认文件丢失</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/nginx/nginxconfig.io:/etc/nginx/nginxconfig.io</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/nginx/sites-enabled:/etc/nginx/sites-enabled</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/nginx/sites-available:/etc/nginx/sites-available</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/nginx/nginx.conf:/etc/nginx/nginx.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/nginx/public:/var/www/mimimimimi.top/public</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/etc/letsencrypt:/etc/letsencrypt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/nginx:/var/www/_letsencrypt</span> <span class="comment"># 配合certbot, letsencrypt校验用</span></span><br></pre></td></tr></table></figure>
<p>修改后别忘了重启nginx镜像</p>
<p>由于免费证书90天失效,之后还可以在服务器中通过<code>crontab</code>设置定时任务重起certbot容器,来重新生成证书</p>
<p><a href="https://www.digitalocean.com/community/tools/nginx?domains.0.https.letsEncryptEmail=393223434@qq.com&domains.0.logging.accessLog=true&domains.0.logging.errorLog=true&domains.0.php.php=false&domains.0.reverseProxy.reverseProxy=true&domains.0.reverseProxy.path=/forProxy&domains.0.reverseProxy.proxyPass=http://127.0.0.1:9999&domains.0.routing.index=index.html&domains.0.routing.fallbackHtml=true&domains.0.routing.fallbackPhp=false&domains.0.server.domain=mimimimimi.top&domains.0.server.wwwSubdomain=true&global.docker.dockerCompose=true&global.nginx.user=nginx&global.nginx.pid=/var/run/nginx.pid">参考修改</a><br><a href="https://certbot.eff.org/docs/install.html#running-with-docker">certbot running-with-docker</a><br><a href="https://certbot.eff.org/docs/using.html#webroot">certbot webroot</a><br><a href="https://segmentfault.com/a/1190000005797776">参考</a><br><a href="https://www.cnblogs.com/gao88/p/10596143.html">定时更新参考</a><br><a href="https://gitee.com/mimimimimi/docker_nginx_certbot">代码留存</a></p>
]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo again</title>
    <url>/2021/04/25/hexoagain/</url>
    <content><![CDATA[<p>时隔多年再次更新下blog, 更新下主题, 想着记录点儿什么~</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用fabric完成多边形选区</title>
    <url>/2021/05/06/%E4%BD%BF%E7%94%A8fabric%E5%AE%8C%E6%88%90%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%80%89%E5%8C%BA/</url>
    <content><![CDATA[<p><img src="draw.gif" alt="a"></p>
<p>之前有过这么个需求, 说是要在图片中选区(车站,广场等),然后选区的要求是<strong>不规则凸多边形</strong> <strong>按点连接</strong>, 之后要获取选区点坐标, 同时也有将生成点坐标回显展示选区的需求, 在一番调研之后决定使用<a href="http://fabricjs.com/">fabric.js</a>来实现功能</p>
<blockquote>
<p>Fabric是一个强大而简单的JS Canvas库，我们能通过使用它实现在Canvas上创建、填充图形、给图形填充渐变颜色。 组合图形（包括组合图形、图形文字、图片等）等一系列功能。简单来说我们可以通过使用Fabric从而以较为简单的方式实现较为复杂的Canvas功能</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>整个的思路大概是先初始化fabric实例,将图片展示到canvas上,根据图片和canvas的尺寸得到缩放比例,方便将后续得到的点坐标按图片尺寸还原.接着通过鼠标点击在canvas上绘制点,将点按照点击顺序连接成线,则得到多边形的边,此时三个点以上则可连接成多边形,当点击完成时将<strong>起始点</strong>与<strong>终点</strong>连接闭合成多边形.</p>
<p><img src="draw-close.png" alt="draw-close"></p>
<p>其中核心的问题则是按顺序连接的点,当图形完成,起始点和终点连接时,选区图形是否能成为一个多边形?此处我采用的方式是, 通过鼠标移动,可以落点时鼠标同首尾点连接虚线,当无法绘制所需多边形时隐藏虚线并<strong>无法落点</strong>,确保已经绘制的点之间可连成多边形</p>
<p><img src="draw-cross.png" alt="draw-cross"></p>
<p>即核心的判断则是:</p>
<ul>
<li>起始点与鼠标连线:line1,终点与鼠标连线:line2,则line1,line2是否<strong>同时</strong>与已连接的线段<strong>相交</strong>, 同时相交则无法落点<br><img src="draw2.png" alt="draw2"></li>
<li><strong>已连接线段中除首尾两条外</strong>, 是否存在line1<strong>或</strong>line2与某条线段相交, 相交则无法落点<br><img src="draw3.png" alt="draw3"></li>
<li>通过向量叉乘判断线段相交<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算向量叉乘</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">crossMul</span>(<span class="params">v1, v2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1.x * v2.y - v1.y * v2.x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断两条线段是否相交line1(p1,p2) line2(p3,p4)</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">checkCross</span>(<span class="params">p1, p2, p3, p4</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v1 = &#123; <span class="attr">x</span>: p1.x - p3.x, <span class="attr">y</span>: p1.y - p3.y &#125;,</span><br><span class="line">      v2 = &#123; <span class="attr">x</span>: p2.x - p3.x, <span class="attr">y</span>: p2.y - p3.y &#125;,</span><br><span class="line">      v3 = &#123; <span class="attr">x</span>: p4.x - p3.x, <span class="attr">y</span>: p4.y - p3.y &#125;,</span><br><span class="line">      v = crossMul(v1, v3) * crossMul(v2, v3);</span><br><span class="line">    v1 = &#123; <span class="attr">x</span>: p3.x - p1.x, <span class="attr">y</span>: p3.y - p1.y &#125;;</span><br><span class="line">    v2 = &#123; <span class="attr">x</span>: p4.x - p1.x, <span class="attr">y</span>: p4.y - p1.y &#125;;</span><br><span class="line">    v3 = &#123; <span class="attr">x</span>: p2.x - p1.x, <span class="attr">y</span>: p2.y - p1.y &#125;;</span><br><span class="line">    <span class="keyword">return</span> v &lt;= <span class="number">0</span> &amp;&amp; crossMul(v1, v3) * crossMul(v2, v3) &lt;= <span class="number">0</span></span><br><span class="line">      ? <span class="literal">true</span></span><br><span class="line">      : <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>首先页面上要有个canvas容器,据此生成fabric的canvas实例,还要将图片展示在canvas中,然后根据图片尺寸,canvas尺寸得到展示的缩放比例<code>radio</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> convasDefaultWidth = <span class="number">500</span>;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="keyword">var</span> image = <span class="keyword">new</span> fabric.Image(<span class="built_in">document</span>.getElementById(<span class="string">&quot;image&quot;</span>));</span><br><span class="line">      <span class="keyword">var</span> imageWidth = image.get(<span class="string">&quot;width&quot;</span>);</span><br><span class="line">      <span class="keyword">var</span> canvasWidth =</span><br><span class="line">        imageWidth &gt; convasDefaultWidth ? convasDefaultWidth : imageWidth;</span><br><span class="line">      <span class="comment">// 缩放比例</span></span><br><span class="line">      <span class="keyword">var</span> radio = imageWidth / canvasWidth;</span><br><span class="line">      <span class="comment">// fabfric实例</span></span><br><span class="line">      <span class="keyword">var</span> canvas = <span class="keyword">new</span> fabric.Canvas(<span class="string">&quot;canvas&quot;</span>, &#123;</span><br><span class="line">        width: canvasWidth,</span><br><span class="line">        height: image.get(<span class="string">&quot;height&quot;</span>) / radio,</span><br><span class="line">        backgroundImage: image.scaleToWidth(canvasWidth),</span><br><span class="line">        backgroundColor: <span class="string">&#x27;transparent&#x27;</span>,</span><br><span class="line">        selection:<span class="literal">false</span></span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>
<p>当绘制完成或回显时, 直接使用fabric绘制多边形即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> polygon = <span class="keyword">new</span> fabric.Polygon([], &#123;</span><br><span class="line">        strokeWidth: <span class="number">2</span>,</span><br><span class="line">        stroke: <span class="string">&quot;green&quot;</span>,</span><br><span class="line">        fill: <span class="string">&quot;transparent&quot;</span>,</span><br><span class="line">        objectCaching: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// transparentCorners: false,</span></span><br><span class="line">        <span class="comment">// cornerColor: &quot;blue&quot;,</span></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 添加到画布</span></span><br><span class="line">      canvas.add(polygon);</span><br></pre></td></tr></table></figure>
<p>初始化各个状态,以及将来鼠标显示的连接线等</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 已绘制点</span></span><br><span class="line"><span class="keyword">var</span> points = [];</span><br><span class="line"><span class="comment">// 当前是否可以落点</span></span><br><span class="line"><span class="keyword">var</span> canAddPoint = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 已存在线段</span></span><br><span class="line"><span class="keyword">var</span> existLines = [];</span><br><span class="line"><span class="comment">// 绘制是否完成</span></span><br><span class="line"><span class="keyword">var</span> isCompelete = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 线段默认配置</span></span><br><span class="line"><span class="keyword">var</span> lineOption = &#123;</span><br><span class="line">  strokeWidth: <span class="number">2</span>,</span><br><span class="line">  stroke: <span class="string">&quot;green&quot;</span>,</span><br><span class="line">  fill: <span class="string">&quot;green&quot;</span>,</span><br><span class="line">  selectable: <span class="literal">false</span>,</span><br><span class="line">  evented: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 连接线使用虚线</span></span><br><span class="line"><span class="keyword">var</span> dashLineOption = <span class="built_in">Object</span>.assign(&#123;&#125;,lineOption,&#123;<span class="attr">strokeDashArray</span>: [<span class="number">10</span>, <span class="number">15</span>]&#125;)</span><br><span class="line"><span class="comment">// 鼠标连接线</span></span><br><span class="line"><span class="keyword">var</span> combineLineWithFirst = <span class="keyword">new</span> fabric.Line([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], dashLineOption);</span><br><span class="line"><span class="keyword">var</span> combineLineWithSecond = <span class="keyword">new</span> fabric.Line([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], dashLineOption);</span><br><span class="line"><span class="comment">// 添加至canvas</span></span><br><span class="line">canvas.add(combineLineWithFirst);</span><br><span class="line">canvas.add(combineLineWithSecond);</span><br></pre></td></tr></table></figure>
<p>初始化fabric canvas的鼠标事件,即鼠标移动和点击</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移动</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canvasHandleMouseMove</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pointsLen = points.length;</span><br><span class="line">  <span class="keyword">if</span> (pointsLen === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 起点与终点</span></span><br><span class="line">  <span class="keyword">var</span> firstPoint = points[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> lastPoint = points[pointsLen - <span class="number">1</span>];</span><br><span class="line">  <span class="comment">// 两点以上</span></span><br><span class="line">  <span class="keyword">if</span> (pointsLen &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 已绘制的线段</span></span><br><span class="line">    <span class="keyword">var</span> exlines = getLinesArr();</span><br><span class="line">    <span class="keyword">var</span> hasCross = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; exlines.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> perline = exlines[i];</span><br><span class="line">      <span class="keyword">var</span> point1 = &#123; <span class="attr">x</span>: perline[<span class="number">0</span>], <span class="attr">y</span>: perline[<span class="number">1</span>] &#125;;</span><br><span class="line">      <span class="keyword">var</span> point2 = &#123; <span class="attr">x</span>: perline[<span class="number">2</span>], <span class="attr">y</span>: perline[<span class="number">3</span>] &#125;;</span><br><span class="line">      <span class="comment">// 根据之前所说的判断条件</span></span><br><span class="line">      <span class="comment">// line1,line2是否同时与已连接的线段相交</span></span><br><span class="line">      <span class="comment">// 或 存在line1或line2与某条线段相交</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        checkCross(options.pointer, firstPoint, point1, point2) &amp;&amp;</span><br><span class="line">        checkCross(options.pointer, lastPoint, point1, point2)</span><br><span class="line">      ) &#123;</span><br><span class="line">        hasCross = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i &lt; exlines.length - <span class="number">1</span> &amp;&amp; (checkCross(options.pointer, firstPoint, point1, point2) ||</span><br><span class="line">      checkCross(options.pointer, lastPoint, point1, point2)))&#123;</span><br><span class="line">        hasCross = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 能落点, 绘制鼠标连接线</span></span><br><span class="line">  <span class="keyword">if</span> (!hasCross) &#123;</span><br><span class="line">    canAddPoint = <span class="literal">true</span>;</span><br><span class="line">    setLineWithPoint(combineLineWithFirst, options.pointer, firstPoint);</span><br><span class="line">    setLineWithPoint(combineLineWithSecond, options.pointer, lastPoint);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 隐藏鼠标连接线</span></span><br><span class="line">    canAddPoint = <span class="literal">false</span>;</span><br><span class="line">    setLineWithPoint(combineLineWithFirst);</span><br><span class="line">    setLineWithPoint(combineLineWithSecond);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// fabric 绘制</span></span><br><span class="line">  canvas.renderAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点击</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canvasHandleMouseDown</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!canAddPoint) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">var</span> pointsLen = points.length;</span><br><span class="line">        <span class="keyword">var</span> lastPoint = points[pointsLen - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          lastPoint &amp;&amp;</span><br><span class="line">          options.pointer.x === lastPoint.x &amp;&amp;</span><br><span class="line">          options.pointer.y === lastPoint.y</span><br><span class="line">        )</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// console.log(options, options.pointer.x, options.pointer.y);</span></span><br><span class="line">        <span class="comment">// 落点, 注意精度</span></span><br><span class="line">        points.push(&#123;</span><br><span class="line">          x: +options.pointer.x.toFixed(<span class="number">3</span>),</span><br><span class="line">          y: +options.pointer.y.toFixed(<span class="number">3</span>),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 落点连接线段</span></span><br><span class="line">        <span class="keyword">if</span> (lastPoint) &#123;</span><br><span class="line">          <span class="keyword">var</span> line = <span class="keyword">new</span> fabric.Line(</span><br><span class="line">            [lastPoint.x, lastPoint.y, options.pointer.x, options.pointer.y],</span><br><span class="line">            lineOption</span><br><span class="line">          );</span><br><span class="line">          canvas.add(line);</span><br><span class="line">          existLines.push(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        canvas.requestRenderAll();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>当绘制完成或回显时则将鼠标连接线隐藏, 切换完成状态, 通过已绘制的点连接生成多边形,而重置则清空画布并重置状态即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多边形回显</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">drowPolygon</span>(<span class="params">points</span>) </span>&#123;</span><br><span class="line">        isCompelete = <span class="literal">true</span>;</span><br><span class="line">        polygon.set(<span class="string">&quot;points&quot;</span>, points);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>后续再优化的话 其实可以开放fabric多边形的锚点拖拽,旋转,形变等等</p>
<p><a href="https://gitee.com/workthing/canvas_polycon">demo完整代码</a></p>
]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
      <tags>
        <tag>工作中</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次jenkins相关被挖矿处理的应对</title>
    <url>/2021/04/27/jenkins-bug/</url>
    <content><![CDATA[<h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p>事件的起源其实是上次更新blog后的疑问</p>
<blockquote>
<p>时隔多年再次更新下blog, 更新下主题, 想着记录点儿什么~</p>
</blockquote>
<p>虽说想法是好的, 但作为一个资深<code>沉默的观察员</code>的我, 自然是 <code>当我沉默着的时候,我觉得充实,我将开口,同时感到空虚</code>, 所以平时看看还好, 真要张嘴马上无话可说了, 平时没事儿就思考人生,想起自己毕业时写的一个静态页面, 那是一个介绍我当时玩的游戏的小页面, 想着正好服务器,域名都空着没用, 不妨把这个当时照着视频教程开发的小页面放上去试试, 也算纪念下回归初心</p>
<p>说干就干, 本地ssh登录服务器时却登不上, 之前可能卡了点还总断,但好歹是能登上的, 这回<code>ssh -i</code>指定密钥的情况下却仍提示输入密码, 哪怕密码正确(特意重置了😭)也不断提示重新输入密码直到<code>Permission denied</code>, 明明指定密钥不需要再输密码来着, 看来是哪里出了问题, 到控制台网页登录,发现密钥/密码都是ok的, 只好翻翻<a href="https://cloud.tencent.com/document/product/213/35574#ssh-.E9.97.AE.E9.A2.98.E5.AF.BC.E8.87.B4.E6.97.A0.E6.B3.95.E7.99.BB.E5.BD.95">文档</a>找解决方案</p>
<h3 id="应对"><a href="#应对" class="headerlink" title="应对"></a>应对</h3><p>一条条对下来发现有条对应<strong>服务器高负载</strong>相关的, 到实例监控上看, 好嘛, cpu果然已经飙到极限了</p>
<p><img src="tencentdoc.png" alt="tencentdoc"><br><img src="cloudserve.png" alt="cloudserve"></p>
<ul>
<li><p>在一通搜索下得知, 通过<code>top</code>命令查看当前cpu运行相关状态</p>
<p><img src="termial_1.png" alt="termial_1.png"></p>
</li>
<li><p>通过输入k 指定pid,我们可以直接kill掉占用cpu过高的trace进程, 但多次杀进程这个trace却总会重启, 接着我们通过<code>PID</code>来找到对应进程和所在目录, pid的查看除<code>top</code>外也可使用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef |grep [Pname 进程名]</span><br></pre></td></tr></table></figure>
<p>从上图的最后运行<code>ps -ef |grep trace</code>的返回可见到一些关键信息, 像什么<code>mine.c3pool.com</code>一看就是老矿工了, <code>2020jenkins</code>可能就是叛变革命的元凶</p>
</li>
<li><p>通过<code>PID</code>来找到对应进程和所在目录则使用, 其中 <strong>/proc目录中包含许多以数字命名的子目录，这些数字表示系统当前正在运行进程的进程号，里面包含对应进程相关的多个信息文件</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls -l /proc/[PID]</span><br><span class="line">当然直接 <span class="built_in">cd</span> /proc/[PID] 再 ll也是一样的</span><br><span class="line">再就是</span><br><span class="line">pwdx [PID]</span><br></pre></td></tr></table></figure>
<p>当时忘了截图, 应该和以下相似, 当时的exe和pwd都指向 <code>/var/jenkins_home/XXX../trace</code>但我服务器本地是没有这个目录的<br><img src="terminal_3.png" alt="terminal"><br>考虑到我的jenkins是docker起的, 马上找到对应的挂载目录, 从<code>jenkins_home</code>一路找到这个<code>trace</code>, 但发现就算将trace删除它也马上会再自动生成😱,接下来通过<strong>jenkins</strong>作为关键字通过网络搜索果然能发现些端倪, 参考<a href="https://www.jianshu.com/p/70e071113044?from=groupmessage&isappinstalled=0">这篇</a>和<a href="https://blog.csdn.net/g6U8W7p06dCO99fQ3/article/details/90205674">这篇</a>基本上能确定我碰上的也是这种情况了,登上jenkins一看果然再一直重复跑着几个不是我建的build<br><img src="jenkins_dashbord.png" alt="jenkins_dashbord"></p>
</li>
</ul>
<p>之后处理则是按照以下顺序:</p>
<ul>
<li>禁用Jenkins task</li>
<li>升级Jenkins版本</li>
<li>检查定时任务脚本</li>
</ul>
<h3 id="升级Jenkins版本"><a href="#升级Jenkins版本" class="headerlink" title="升级Jenkins版本"></a>升级Jenkins版本</h3><p>禁用Jenkins task不必多言直接在页面上设置禁用即可, 主要是升级Jenkins版本, 页面上也有提示升级,点击却一直升级失败(可能是网络等原因,关键文件下载失败之类的,这不是很常见吗), 鉴于我的jenkins是docker跑的, 参考网上的一些文章,通过更新容器中的war包来升级jenkins:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入jenkins容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it [jenkins contanerID] sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#下载新包</span></span><br><span class="line"><span class="built_in">cd</span> /var/jenkins</span><br><span class="line">wget http://mirrors.jenkins.io/war/latest/jenkins.war</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入war包的存放路径，备份旧包，新包代替</span></span><br><span class="line">somehost$:/<span class="comment"># cd /usr/share/jenkins/</span></span><br><span class="line">somehost$:/usr/share/jenkins<span class="comment"># ls</span></span><br><span class="line">jenkins.war</span><br><span class="line"> </span><br><span class="line">somehost$:/usr/share/jenkins<span class="comment"># mv jenkins.war jenkins.war-bak</span></span><br><span class="line">somehost$:/usr/share/jenkins<span class="comment"># cp /var/jenkins_home/jenkins.war .</span></span><br><span class="line">somehost$:/usr/share/jenkins<span class="comment"># ls</span></span><br><span class="line">jenkins.war  jenkins.war-bak</span><br><span class="line"> </span><br><span class="line">somehost$:/usr/share/jenkins<span class="comment"># exit </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重启容器</span></span><br><span class="line">docker restart [jenkins contanerID]</span><br></pre></td></tr></table></figure>
<p>之后重新访问jenkins页面就会发现jenkins在准备升级,稍后就会完成升级, 升级后的jenkins则会提示<a href="https://wiki.jenkins.io/display/JENKINS/Security+implication+of+building+on+master">已有风险</a><br><img src="jenkins_doc_security.png" alt="jenkins_doc_security"><br>看起来好像说的是通过jenkins controller直接运行的build能直接读写<code>$JENKINS_HOME</code>的文件,相当于能触及像安装插件,读凭证,创建新job等几乎所有操作了, 所以貌似是建议通过其他服务器,来代理跑构建任务(<code>agent</code>), 否则的话就要好好检查下<code>$JENKINS_HOME</code>的权限了, jenkins我暂时用不上,先按上面设置把执行器改成零<br><img src="jenkins_node.png" alt="jenkins_node"></p>
<h3 id="检查定时任务脚本"><a href="#检查定时任务脚本" class="headerlink" title="检查定时任务脚本"></a>检查定时任务脚本</h3><p>接下来再检查下服务器在跑啥定时脚本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">crontab -l <span class="comment"># 查看</span></span><br><span class="line">crontab -r <span class="comment"># 清空</span></span><br></pre></td></tr></table></figure>
<p><img src="terminal_4.png" alt="terminal_4"></p>
<p>确实发现了个我毫无印象的脚本, 也没多想,直接被我<code>crontab -r</code>了, 一套操作下来<code>top</code>命令查看后, cpu使用已然恢复正常(服务器更本没跑啥,占用率趋近于0了), 罪魁祸首trace也不再复活, 也算是「一件落着/いっけんらくちゃく」</p>
<h3 id="终局"><a href="#终局" class="headerlink" title="终局"></a>终局</h3><p>解决后回到本地ssh登录服务器,发现仍是</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@xxx.xx.xx.xxx<span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string">Permission denied, please try again.</span></span><br><span class="line"><span class="string">root@xxx.xx.xx.xxx&#x27;</span>s password: </span><br><span class="line">root@xxx.xx.xx.xxx: Permission denied (publickey,gssapi-keyex,gssapi-with-mic,pa</span><br><span class="line">ssword)</span><br></pre></td></tr></table></figure>
<p>fuck sake,这就太令人奇怪啦,参考网上修改 <code>/etc/ssh/ssh_config</code> 开启密码验证, root用户登录等选项重启ssh服务啥的都试了一遍, 还是不管用, 最后的最后发现从最开始本地登录时的公网ip就打错了一位, 真的是知道结局的我眼泪落下来, 残念</p>
<h3 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h3><p>登录上服务器就好说了, 把之前的静态文件上传上去就好, 看着自己最最开始写的页面真是感慨万千, 仿佛当时的情感又涌上心头, 可现在的自己又有多少成长呢, 是否又失去了大把可能性, 变得越来越无趣了呢. </p>
<p>ps. 服务器域名估计今年中旬就到期了,姑且先放着几天吧, <a href="https://www.mimimimimi.top/">www.mimimimimi.top</a>, 这游戏是我大学要毕业时玩儿的, 当时记得通关一周目普通模式死了300多次, 像素游戏小而精美,很有旺达与巨像的味道, 那几天下来脑袋里都是这款游戏, 哈哈, 毕设要写啥,舍友们都在发愁, 我想着要不然就写个介绍这个游戏的”小网站”吧, 这么多年后它终于被我再次想起,成功上线了😏 </p>
]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>ssh</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用mapbox做大屏展示3d建筑地图</title>
    <url>/2021/05/01/%E4%BD%BF%E7%94%A8mapbox%E5%81%9A%E5%A4%A7%E5%B1%8F%E5%B1%95%E7%A4%BA3d%E5%BB%BA%E7%AD%91%E5%9C%B0%E5%9B%BE/</url>
    <content><![CDATA[<p>简单记录下使用 mapbox 展示 3d 建筑物地图</p>
<h4 id="使用map-studio制作的样式"><a href="#使用map-studio制作的样式" class="headerlink" title="使用map studio制作的样式"></a>使用map studio制作的样式</h4><p><img src="mapbox-studio.png" alt="map studio"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> mapboxgl.Map(&#123;</span><br><span class="line">  version: <span class="number">8</span>,</span><br><span class="line">  name: <span class="string">&quot;Basic&quot;</span>,</span><br><span class="line">  center: [<span class="number">120.31463022979744</span>, <span class="number">36.06658532033572</span>],</span><br><span class="line">  <span class="comment">// center: [116.89909930420157, 36.666567085091614],</span></span><br><span class="line">  zoom: <span class="number">16</span>,</span><br><span class="line">  bearing: <span class="number">11.199999999999818</span>,</span><br><span class="line">  pitch: <span class="number">60</span>,</span><br><span class="line">  sources: &#123;</span><br><span class="line">    composite: &#123;</span><br><span class="line">      url: <span class="string">&quot;mapbox://mapbox.mapbox-streets-v8&quot;</span>,</span><br><span class="line">      type: <span class="string">&quot;vector&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 使用 mapbox studio制作分享的样式</span></span><br><span class="line">  style: <span class="string">&quot;mapbox://styles/wumi/ckew6c8b60g2s19pij43gk4ft&quot;</span>,</span><br><span class="line">  container: <span class="string">&quot;map&quot;</span>,</span><br><span class="line">  antialias: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3d-buildings"><a href="#3d-buildings" class="headerlink" title="3d-buildings"></a><a href="https://docs.mapbox.com/mapbox-gl-js/example/3d-buildings/">3d-buildings</a></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> layers = map.getStyle().layers</span><br><span class="line"></span><br><span class="line">     <span class="keyword">var</span> labelLayerId</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; layers.length; i++) &#123;</span><br><span class="line">       <span class="keyword">if</span> (layers[i].type === <span class="string">&#x27;symbol&#x27;</span> &amp;&amp; layers[i].layout[<span class="string">&#x27;text-field&#x27;</span>]) &#123;</span><br><span class="line">         labelLayerId = layers[i].id</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// layer 3d buliding</span></span><br><span class="line">     map.addLayer(</span><br><span class="line">       &#123;</span><br><span class="line">         id: <span class="string">&#x27;3d-buildings&#x27;</span>,</span><br><span class="line">         source: <span class="string">&#x27;composite&#x27;</span>,</span><br><span class="line">         <span class="string">&#x27;source-layer&#x27;</span>: <span class="string">&#x27;building&#x27;</span>,</span><br><span class="line">         filter: [<span class="string">&#x27;==&#x27;</span>, <span class="string">&#x27;extrude&#x27;</span>, <span class="string">&#x27;true&#x27;</span>],</span><br><span class="line">         type: <span class="string">&#x27;fill-extrusion&#x27;</span>,</span><br><span class="line">         minzoom: <span class="number">15</span>,</span><br><span class="line">         paint: &#123;</span><br><span class="line">           <span class="string">&#x27;fill-extrusion-color&#x27;</span>: [<span class="string">&#x27;interpolate&#x27;</span>, [<span class="string">&#x27;exponential&#x27;</span>, <span class="number">1</span>], [<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;height&#x27;</span>], <span class="number">0</span>, <span class="string">&#x27;hsl(175, 59%, 51%)&#x27;</span>, <span class="number">50</span>, <span class="string">&#x27;hsl(244, 81%, 46%)&#x27;</span>],</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 使用“插值”表达式为</span></span><br><span class="line">           <span class="comment">// 建筑物作为用户放大</span></span><br><span class="line">           <span class="string">&#x27;fill-extrusion-height&#x27;</span>: [<span class="string">&#x27;interpolate&#x27;</span>, [<span class="string">&#x27;linear&#x27;</span>], [<span class="string">&#x27;zoom&#x27;</span>], <span class="number">15</span>, <span class="number">0</span>, <span class="number">15.05</span>, [<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;height&#x27;</span>]],</span><br><span class="line">           <span class="string">&#x27;fill-extrusion-base&#x27;</span>: [<span class="string">&#x27;interpolate&#x27;</span>, [<span class="string">&#x27;linear&#x27;</span>], [<span class="string">&#x27;zoom&#x27;</span>], <span class="number">15</span>, <span class="number">0</span>, <span class="number">15.05</span>, [<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;min_height&#x27;</span>]],</span><br><span class="line">           <span class="string">&#x27;fill-extrusion-opacity&#x27;</span>: <span class="number">0.6</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       labelLayerId</span><br><span class="line">     )</span><br></pre></td></tr></table></figure>

<h4 id="添加-GeoJSON-多边形"><a href="#添加-GeoJSON-多边形" class="headerlink" title="添加 GeoJSON 多边形"></a><a href="https://www.mapbox.cn/mapbox-gl-js/example/geojson-polygon/">添加 GeoJSON 多边形</a></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// layer fill geojson https://www.mapbox.cn/mapbox-gl-js/example/geojson-polygon/</span></span><br><span class="line">map.addLayer(&#123;</span><br><span class="line">  id: <span class="string">&quot;geoPolygon_2&quot;</span>,</span><br><span class="line">  type: <span class="string">&quot;fill&quot;</span>,</span><br><span class="line">  source: &#123;</span><br><span class="line">    type: <span class="string">&quot;geojson&quot;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      type: <span class="string">&quot;Feature&quot;</span>,</span><br><span class="line">      geometry: &#123;</span><br><span class="line">        type: <span class="string">&quot;Polygon&quot;</span>,</span><br><span class="line">        coordinates: [</span><br><span class="line">          [</span><br><span class="line">            [<span class="number">120.31386645128458</span>, <span class="number">36.07352407299466</span>],</span><br><span class="line">            [<span class="number">120.31406051266816</span>, <span class="number">36.06973548187716</span>],</span><br><span class="line">            [<span class="number">120.31703395879913</span>, <span class="number">36.067476673147524</span>],</span><br><span class="line">            [<span class="number">120.31903338030969</span>, <span class="number">36.06914023164856</span>],</span><br><span class="line">            [<span class="number">120.31725031669936</span>, <span class="number">36.072912209593554</span>],</span><br><span class="line">            [<span class="number">120.31386645128458</span>, <span class="number">36.07352407299466</span>],</span><br><span class="line">            <span class="comment">// [116.90015862619504, 36.67485225304701],</span></span><br><span class="line">            <span class="comment">// [116.89925746159167, 36.66643736142822],</span></span><br><span class="line">            <span class="comment">// [116.90449322417288, 36.66646071375989],</span></span><br><span class="line">            <span class="comment">// [116.90474640425532, 36.674772049527036],</span></span><br><span class="line">            <span class="comment">// [116.90015862619504, 36.67485225304701]</span></span><br><span class="line">          ],</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  layout: &#123;&#125;,</span><br><span class="line">  paint: &#123;</span><br><span class="line">    <span class="string">&quot;fill-color&quot;</span>: <span class="string">&quot;#0becff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;fill-opacity&quot;</span>: <span class="number">0.5</span>,</span><br><span class="line">    <span class="string">&quot;fill-outline-color&quot;</span>: <span class="string">&quot;#15def2&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="添加弹层"><a href="#添加弹层" class="headerlink" title="添加弹层"></a><a href="https://www.mapbox.cn/mapbox-gl-js/api/#popup">添加弹层</a></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add marker popup</span></span><br><span class="line">      <span class="keyword">var</span> popup = <span class="keyword">new</span> mapboxgl.Popup(&#123;</span><br><span class="line">        offset: [<span class="number">180</span>, -<span class="number">20</span>],</span><br><span class="line">        className: <span class="string">&#x27;IBM_popup&#x27;</span>,</span><br><span class="line">        maxWidth: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">      &#125;).setText(<span class="string">&#x27;某某站&#x27;</span>)</span><br><span class="line">      <span class="comment">// create DOM element for the marker</span></span><br><span class="line">      <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">      el.innerHTML = <span class="string">&#x27;&lt;span&gt;点位&lt;/span&gt;&#x27;</span></span><br><span class="line">      el.id = <span class="string">&#x27;marker&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// create the marker</span></span><br><span class="line">      <span class="keyword">new</span> mapboxgl.Marker(el)</span><br><span class="line">        .setLngLat([<span class="number">120.31319853001287</span>, <span class="number">36.069633414671344</span>])</span><br><span class="line">        <span class="comment">// .setLngLat([116.89759274743653, 36.66859665993769])</span></span><br><span class="line">        .setPopup(popup) <span class="comment">// sets a popup on this marker</span></span><br><span class="line">        .addTo(map)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="最后效果"><a href="#最后效果" class="headerlink" title="最后效果"></a>最后效果</h4><p><img src="mapbox1.png" alt="map1"><br><img src="mapbox2.png" alt="map1"><br><img src="mapbox3.png" alt="map1"></p>
<p><a href="https://zhuanlan.zhihu.com/p/65248694">Mapbox Studio</a></p>
<p>先挖个坑 😂 <a href="https://gitee.com/workthing/ruoyuan">demo地址</a></p>
]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
      <tags>
        <tag>工作中</tag>
      </tags>
  </entry>
  <entry>
    <title>常见面试算法</title>
    <url>/2021/08/26/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></p>
<details>
<summary>展开查看</summary>
  <pre>
  <code>
   var reverseList = function(head) &#123;
    if (!head) return null;
    let pre = null, cur = head;
    while (cur) &#123;
        // 关键: 保存下一个节点的值
        let next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    &#125;
    return pre;
  &#125;;
  </code>
  </pre>
</details></li>
</ul>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">链表回文</a></p>
</li>
<li><p>合并两个升序链表</p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并k个升序链表</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/sort-list/">链表排序</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">链表相交</a></p>
</li>
<li><p>链表倒数第k项值 (双指针,慢指针等待k步)</p>
</li>
</ul>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">最长公共前缀</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">最长无重复字符串</a></p>
</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li><p><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">最长连续递增序列</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">删除有序数组中的重复项</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/two-sum/submissions/">两数之和</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">两数之和 II - 输入有序数组</a></p>
</li>
</ul>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul>
<li><p>深度优先遍历 (前序,中序,后序)</p>
</li>
<li><p>广度优先遍历 (层序)</p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">二叉树最大深度</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">二叉树的最小深度</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">将有序数组转换为二叉搜索树</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">验证二叉搜索树</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">验证平衡二叉树</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">二叉树的最近公共祖先</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">二叉搜索树中的搜索</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">二叉树的锯齿形层序遍历【二叉树】</a></p>
</li>
</ul>
<p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x26epd/">Leetcode 初级算法</a></p>
<p><a href="http://47.98.159.95/leetcode-js/nav/">前端算法练习指南</a></p>
<p><a href="https://juejin.cn/post/6947842412102287373">字节跳动最爱考的 64 道算法题</a></p>
<p>未来再更…</p>
]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>IOC与DI,Decorator,reflect Matedata</title>
    <url>/2021/10/10/IOC%E4%B8%8EDI-reflect-Matedata/</url>
    <content><![CDATA[<blockquote>
<p>内容来自互联网, 仅用于个人学习记忆</p>
</blockquote>
<h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><p>IoC（Inversion of Control）控制反转,是面向对象编程中的一种设计原则，用来降低计算机代码之间的耦合度</p>
<blockquote>
<p>在传统面向对象的编码过程中，当类与类之间存在依赖关系时，通常会直接在类的内部创建依赖对象，这样就导致类与类之间形成了耦合，依赖关系越复杂，耦合程度就会越高，而耦合度高的代码会非常难以进行修改和单元测试。而 IoC 则是专门提供一个容器进行依赖对象的创建和查找，将对依赖对象的控制权由类内部交到容器这里，这样就实现了类与类的解耦，保证所有的类都是可以灵活修改</p>
</blockquote>
<h4 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h4><p>在不使用 IoC 的情况下，我们很容易写出来这样的代码：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modB.ts</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  p: <span class="built_in">number</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">p</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.p = p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">&quot;./modA&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; B &#125; <span class="keyword">from</span> <span class="string">&quot;./modB&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  a: A;</span><br><span class="line">  b: B;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="built_in">this</span>.b = <span class="keyword">new</span> B(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>C</code>类需要依赖<code>A</code>,<code>B</code>类 与其耦合, 当随着项目的迭代, 依赖关系发生变化,或依赖项<code>A</code>,<code>B</code>初始化参数变化时, 这种依赖关系将变得难以维护</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">&quot;./modA&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; B &#125; <span class="keyword">from</span> <span class="string">&quot;./modB&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  a: A;</span><br><span class="line">  b: B;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">    <span class="built_in">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B(<span class="string">&quot;what ever&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C(a, b);</span><br></pre></td></tr></table></figure>

<p>实际上对于<code>C</code>类型实例化而言,并不在乎<code>B</code>实例化的参数, 稍加修改只需要通过<code>A</code>,<code>B</code>的实例就可进行构造, 这样就能体现出类与类之间的解耦</p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><blockquote>
<p>虽然我们实现了解耦，但我们仍需要自己初始化所有的类，并以构造函数参数的形式进行传递。如果存在一个全局的容器，里面预先注册好了我们所需对象的类定义以及初始化参数，每个对象有一个唯一的 key。那么当我们需要用到某个对象时，我们只需要告诉容器它对应的 key，就可以直接从容器中取出实例化好的对象，开发者就不用再关心对象的实例化过程，也不需要将依赖对象作为构造函数的参数在依赖链路上传递, 也就是说，我们的容器必须具体两个功能，<strong>实例的注册和获取</strong></p>
</blockquote>
<p>即我们可以构造一个容器,维护未来需要使用的类及其对照关系,当需要具体类型的实例时, 通过对照关系可以找到对应的类, 并在容器中直接初始化</p>
<blockquote>
<p>再举个栗子，当我们想要处对象时，会上 Soul、Summer、陌陌…等等去一个个找，找哪种的与怎么找是由我自己决定的，这叫 <strong>控制正转</strong>。现在我觉得有点麻烦，直接把自己的介绍上传到世纪佳缘，如果有人看上我了，就会主动向我发起聊天，这叫 <strong>控制反转</strong></p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; A &#125; <span class="keyword">from</span> <span class="string">&quot;./modA&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; B &#125; <span class="keyword">from</span> <span class="string">&quot;./modB&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  a: A;</span><br><span class="line">  b: B;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 手动从容器中获取实例</span></span><br><span class="line">    <span class="built_in">this</span>.a = container.get(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.b = container.get(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="keyword">new</span> Container();</span><br><span class="line"><span class="comment">// 手动向容器注册类型</span></span><br><span class="line">container.bind(<span class="string">&quot;a&quot;</span>, A);</span><br><span class="line">container.bind(<span class="string">&quot;b&quot;</span>, B, [<span class="string">&quot;what ever&quot;</span>]);</span><br><span class="line">container.bind(<span class="string">&quot;c&quot;</span>, C);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从容器中取出c</span></span><br><span class="line"><span class="keyword">const</span> c = container.get(<span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>到此为止, 虽然容器完成了类与类的解耦, 但容器的初始化及各类型的注册看上去还是很繁琐的, 如果这部分可以通过封装进框架自动进行, 并且在类实例化时无需手动指定, 而可以直接自动拿到所需实例, 这样就可以更专注于内部逻辑的开发, 及实现依赖注入</p>
<h3 id="DI（Dependency-Injection）依赖注入"><a href="#DI（Dependency-Injection）依赖注入" class="headerlink" title="DI（Dependency Injection）依赖注入"></a>DI（Dependency Injection）依赖注入</h3><p>IoC 是一种思想, 而 DI 是其一种技术实现, 即将依赖注入给调用方,而无需调用发主动获取, 需要解决一下问题</p>
<ul>
<li>程序启动时,所有类型会在容器中自动注册</li>
<li>实例化时类型所需的对象的自动注入, 无需在构造函数中指定</li>
</ul>
<p>而这些即可通过 <code>TS装饰器</code> 结合 <code>Reflect Metadata</code>实现</p>
<h4 id="TS-Decorator"><a href="#TS-Decorator" class="headerlink" title="TS Decorator"></a>TS Decorator</h4><blockquote>
<p>首先在<code>tsconfig.json</code>中设置<code>experimentalDecorators</code>与<code>emitDecoratorMetadata</code>为<code>true</code></p>
</blockquote>
<h5 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addProp</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">  <span class="title">constructor</span>.<span class="title">prototype</span>.<span class="title">sayhi</span> = &quot;<span class="title">hi</span>&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@addProp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> P();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.sayhi); <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>

<p>对于类装饰器来说 入参为 此 Class 即 <strong>构造函数</strong></p>
<h5 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h5><p>方法装饰器的入参为 <strong>类的原型对象</strong> <strong>属性名</strong> 以及 **属性描述符(descriptor)**，其属性描述符包含<code>writable</code> <code>enumerable</code> <code>configurable</code> <code>value</code> ，我们可以在这里去配置其相关信息 类似<code>Object.defineProperty()</code></p>
<blockquote>
<ol>
<li>Either the constructor function of the class for a static member, or the prototype of the class for an instance member.</li>
<li>The name of the member.</li>
<li>The Property Descriptor for the member.</li>
</ol>
</blockquote>
<blockquote>
<p>注意，对于静态成员来说，首个参数会是类的构造函数。而对于实例成员（比如下面的例子），则是类的原型对象</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addProps</span>(<span class="params"></span>): <span class="title">MethodDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, propertyKey, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// A.prototype</span></span><br><span class="line">    <span class="built_in">console</span>.log(target);</span><br><span class="line">    <span class="built_in">console</span>.log(propertyKey);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(descriptor));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="meta">@addProps</span>()</span><br><span class="line">  <span class="function"><span class="title">sayhi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hi~&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h5><p>类似于方法装饰器，但它的入参少了属性描述符。原因则是目前没有方法在定义原型对象成员同时去描述一个实例的属性（创建描述符）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addProp</span>(<span class="params">target, propertyKey</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// A.prototype</span></span><br><span class="line">  <span class="built_in">console</span>.log(target);</span><br><span class="line">  <span class="comment">// 装饰的属性</span></span><br><span class="line">  <span class="built_in">console</span>.log(propertyKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="meta">@addProp</span></span><br><span class="line">  <span class="keyword">public</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h5><p>参数装饰器的入参首要两位与属性装饰器相同，第三个参数则是参数在当前函数参数中的<strong>索引</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paramDeco</span>(<span class="params">params?: <span class="built_in">any</span></span>): <span class="title">ParameterDecorator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, propertyKey, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target);</span><br><span class="line">    <span class="built_in">console</span>.log(propertyKey);</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">    target.constructor.prototype.fromParamDeco = <span class="string">&quot;呀呼！&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">someMethod</span>(<span class="params"><span class="meta">@paramDeco</span>() param: <span class="built_in">any</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;param&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> B().someMethod(<span class="string">&quot;okok&quot;</span>);</span><br><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line"><span class="built_in">console</span>.log(B.prototype.fromParamDeco);</span><br></pre></td></tr></table></figure>

<h5 id="多个装饰器声明"><a href="#多个装饰器声明" class="headerlink" title="多个装饰器声明"></a>多个装饰器声明</h5><blockquote>
<p>As such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:</p>
<ol>
<li> The expressions for each decorator are evaluated top-to-bottom.</li>
<li> The results are then called as functions from bottom-to-top.</li>
</ol>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;first(): factory evaluated&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    propertyKey: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    descriptor: PropertyDescriptor</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;first(): called&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">second</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;second(): factory evaluated&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    propertyKey: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    descriptor: PropertyDescriptor</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;second(): called&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleClass</span> </span>&#123;</span><br><span class="line">  <span class="meta">@first</span>()</span><br><span class="line">  <span class="meta">@second</span>()</span><br><span class="line">  <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Which would print this output to the console:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">first(): factory evaluated</span><br><span class="line">second(): factory evaluated</span><br><span class="line">second(): called</span><br><span class="line">first(): called</span><br></pre></td></tr></table></figure>

<blockquote>
<p>There is a well defined order to how decorators applied to various declarations inside of a class are applied:</p>
<ol>
<li> Parameter Decorators(参数装饰器), followed by Method(方法装饰器), Accessor(如属性 getter 访问符装饰器), or Property Decorators(属性装饰器) are applied for each instance member.</li>
<li> Parameter Decorators, followed by Method, Accessor, or Property Decorators are applied for each static member.</li>
<li> Parameter Decorators are applied for the constructor.</li>
<li> Class Decorators are applied for the class.</li>
</ol>
</blockquote>
<h4 id="Reflect-Metadata"><a href="#Reflect-Metadata" class="headerlink" title="Reflect Metadata"></a>Reflect Metadata</h4><p>Reflect Metadata 是属于 ES7 的一个提案，其主要作用是在声明时去读写元数据</p>
<p>为类或类属性添加了元数据后，构造函数的原型（或是构造函数，根据静态成员还是实例成员决定）会具有<code>[[Metadata]]</code>属性，该属性内部包含一个<code>Map</code>结构，键为属性键，值为元数据键值对。</p>
<h5 id="metadata-方法"><a href="#metadata-方法" class="headerlink" title="metadata 方法"></a>metadata 方法</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">metadataKey</span></span> - 元数据入口的key</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>metadataValue 元数据入口的value</span></span><br><span class="line"><span class="comment">* <span class="doctag">@returns </span>装饰器函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">metadata</span>(<span class="params">metadataKey: <span class="built_in">any</span>, metadataValue: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    (target: <span class="built_in">Function</span>): <span class="built_in">void</span>;</span><br><span class="line">    (target: <span class="built_in">Object</span>, <span class="attr">propertyKey</span>: <span class="built_in">string</span> | symbol): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nameSymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;veloma&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类元数据</span></span><br><span class="line"><span class="meta">@Reflect</span>.metadata(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;class&#x27;</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaDataClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例属性元数据</span></span><br><span class="line">    <span class="meta">@Reflect</span>.metadata(nameSymbol, <span class="string">&#x27;nihao&#x27;</span>)</span><br><span class="line">    <span class="keyword">public</span> name = <span class="string">&#x27;origin&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例方法元数据</span></span><br><span class="line">    <span class="meta">@Reflect</span>.metadata(<span class="string">&#x27;getName&#x27;</span>, <span class="string">&#x27;getName&#x27;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法元数据</span></span><br><span class="line">    <span class="meta">@Reflect</span>.metadata(<span class="string">&#x27;static&#x27;</span>, <span class="string">&#x27;static&#x27;</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">staticMethod</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建元数据类的实例</span></span><br><span class="line"><span class="keyword">const</span> metadataInstance = <span class="keyword">new</span> MetaDataClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取MetaDataClass的name元数据</span></span><br><span class="line"><span class="keyword">const</span> value = <span class="built_in">Reflect</span>.getMetadata(<span class="string">&#x27;name&#x27;</span>, MetaDataClass); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 获取实例中name属性的nameSymbol元数据</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="built_in">Reflect</span>.getMetadata(nameSymbol, metadataInstance, <span class="string">&#x27;name&#x27;</span>); <span class="comment">// nihao</span></span><br><span class="line"><span class="comment">// 获取实例中getName属性的getName元数据</span></span><br><span class="line"><span class="keyword">const</span> methodVal = <span class="built_in">Reflect</span>.getMetadata(<span class="string">&#x27;getName&#x27;</span>, metadataInstance, <span class="string">&#x27;getName&#x27;</span>); <span class="comment">// getName</span></span><br><span class="line"><span class="comment">// 获取元数据类的staticMethod属性的static元数据</span></span><br><span class="line"><span class="keyword">const</span> staticVal = <span class="built_in">Reflect</span>.getMetadata(<span class="string">&#x27;static&#x27;</span>, MetaDataClass, <span class="string">&#x27;staticMethod&#x27;</span>); <span class="comment">// static</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(value, name, methodVal, staticVal); <span class="comment">// undefined nihao getName static</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们注意到，注入在<strong>静态成员</strong> 如类上及静态属性的元数据在取出时<code>target</code>为这个<strong>类</strong>，而注入在<strong>实例成员</strong> 如方法,属性上的元数据在取出时<code>target</code>则为<strong>实例</strong>。原因其实我们实际上在上面的装饰器执行顺序提到了，这是由于<strong>注入在方法、属性、参数上的元数据实际上是被添加在了实例对应的位置上，因此需要实例化才能取出</strong></p>
<h5 id="defineMetadata-方法"><a href="#defineMetadata-方法" class="headerlink" title="defineMetadata 方法"></a>defineMetadata 方法</h5><p>该方法是<code>metadata</code>的定义版本, 也就是非<code>@</code>版本, 会多传一个参数<code>target</code>, 表示待装饰的对象</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">metadataKey</span></span> - 设置或获取时的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">metadataValue</span></span> - 元数据内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">target</span></span> - 待装饰的target</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> <span class="variable">targetKey</span></span> - target的property</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineMetadata</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  metadataKey: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  metadataValue: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  target: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  targetKey: <span class="built_in">string</span> | symbol</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span></span>;</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DefineMetadata</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">staticMethod</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> staticProperty = <span class="string">&quot;static&quot;</span>;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">type</span> = <span class="string">&quot;type&quot;</span>;</span><br><span class="line"><span class="comment">// 给DefineMetadata设置元数据type, 值为class</span></span><br><span class="line"><span class="built_in">Reflect</span>.defineMetadata(<span class="keyword">type</span>, <span class="string">&quot;class&quot;</span>, DefineMetadata);</span><br><span class="line"><span class="comment">// 给DefineMetadata.staticMethod设置元数据type, 值为staticMethod</span></span><br><span class="line"><span class="built_in">Reflect</span>.defineMetadata(<span class="keyword">type</span>, <span class="string">&quot;staticMethod&quot;</span>, DefineMetadata.staticMethod);</span><br><span class="line"><span class="comment">// 给DefineMeatadata.prorotype.getName设置元数据type, 值为method</span></span><br><span class="line"><span class="built_in">Reflect</span>.defineMetadata(<span class="keyword">type</span>, <span class="string">&quot;method&quot;</span>, DefineMetadata.prorotype.getName);</span><br><span class="line"><span class="comment">// 给DefineMetadata的staticProperty属性设置元数据type, 值为staticProperty</span></span><br><span class="line"><span class="built_in">Reflect</span>.defineMetadata(</span><br><span class="line">  <span class="keyword">type</span>,</span><br><span class="line">  <span class="string">&quot;staticProperty&quot;</span>,</span><br><span class="line">  DefineMetadata,</span><br><span class="line">  <span class="string">&quot;staticProperty&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取DefineMetadata身上的type元数据</span></span><br><span class="line"><span class="keyword">const</span> t1 = <span class="built_in">Reflect</span>.getMetadata(<span class="keyword">type</span>, DefineMetadata); <span class="comment">// class</span></span><br><span class="line"><span class="comment">// 获取DefineMetadata.staticMethod身上的type元数据</span></span><br><span class="line"><span class="keyword">const</span> t2 = <span class="built_in">Reflect</span>.getMetadata(<span class="keyword">type</span>, DefineMetadata.staticMethod); <span class="comment">// staticMethod</span></span><br><span class="line"><span class="comment">// 获取DefineMetadata.prototype.getName身上的type元数据</span></span><br><span class="line"><span class="keyword">const</span> t3 = <span class="built_in">Reflect</span>.getMetadata(<span class="keyword">type</span>, DefineMetadata.prototype.getName); <span class="comment">// method</span></span><br><span class="line"><span class="comment">// 获取DefineMetadata上staticProperty属性的type元数据</span></span><br><span class="line"><span class="keyword">const</span> t4 = <span class="built_in">Reflect</span>.getMetadata(<span class="keyword">type</span>, DefineMetadata, <span class="string">&quot;staticProperty&quot;</span>); <span class="comment">// staticProperty</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(t1, t2, t3, t4); <span class="comment">// class staticMethod method staticProperty</span></span><br></pre></td></tr></table></figure>

<p>首先 npm 安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i reflect-metadata --save</span><br></pre></td></tr></table></figure>

<p>When enabled, as long as the reflect-metadata library has been imported, additional design-time type information will be exposed at runtime.</p>
<p>We can see this in action in the following example:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect-metadata&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> x: <span class="built_in">number</span>, <span class="keyword">public</span> y: <span class="built_in">number</span></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _start: Point;</span><br><span class="line">  <span class="keyword">private</span> _end: Point;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@validate</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title">start</span>(<span class="params">value: Point</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._start = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">start</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._start;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@validate</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title">end</span>(<span class="params">value: Point</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._end = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">end</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._end;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  propertyKey: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  descriptor: TypedPropertyDescriptor&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> set = descriptor.set!;</span><br><span class="line"></span><br><span class="line">  descriptor.set = <span class="function"><span class="keyword">function</span> (<span class="params">value: T</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">type</span> = <span class="built_in">Reflect</span>.getMetadata(<span class="string">&quot;design:type&quot;</span>, target, propertyKey);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(value <span class="keyword">instanceof</span> <span class="keyword">type</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">        <span class="string">`Invalid type, got <span class="subst">$&#123;<span class="keyword">typeof</span> value&#125;</span> not <span class="subst">$&#123;<span class="keyword">type</span>.name&#125;</span>.`</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set.call(<span class="built_in">this</span>, value);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> line = <span class="keyword">new</span> Line();</span><br><span class="line">line.start = <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// @ts-ignore</span></span><br><span class="line"><span class="comment">// line.end = &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fails at runtime with:</span></span><br><span class="line"><span class="comment">// &gt; Invalid type, got object not Point</span></span><br></pre></td></tr></table></figure>

<p>The TypeScript compiler will inject design-time type information using the @Reflect.metadata decorator. You could consider it the equivalent of the following TypeScript:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> _start: Point;</span><br><span class="line">  <span class="keyword">private</span> _end: Point;</span><br><span class="line">  <span class="meta">@validate</span></span><br><span class="line">  <span class="meta">@Reflect</span>.metadata(<span class="string">&quot;design:type&quot;</span>, Point)</span><br><span class="line">  <span class="keyword">set</span> <span class="title">start</span>(<span class="params">value: Point</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._start = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">start</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._start;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@validate</span></span><br><span class="line">  <span class="meta">@Reflect</span>.metadata(<span class="string">&quot;design:type&quot;</span>, Point)</span><br><span class="line">  <span class="keyword">set</span> <span class="title">end</span>(<span class="params">value: Point</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._end = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">end</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._end;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>design:type</code> 即是 TS 的内置元数据，你可以理解为 TS 在编译前还手动执行了<code>@Reflect.metadata(&quot;design:type&quot;, Point)</code>。TS 还内置了 <strong><code>design:paramtypes</code>（获取目标参数类型）与<code>design:returntype</code>（获取方法返回值类型）</strong> 这两种元数据字段来提供帮助。但有一点需要注意，即使对于基本类型，这些元数据也返回对应的包装类型，如<code>number -&gt; [Function: Number]</code></p>
<h3 id="DI-Provider"><a href="#DI-Provider" class="headerlink" title="DI Provider"></a>DI Provider</h3><p>回到我们刚刚提到的问题，我们需要在应用启动的时候自动对所有类进行定义和参数的注册，问题是并不是所有的类都需要注册到容器中，我们并不清楚哪些类需要注册的，同时也不清楚需要注册的类，它的初始化参数是什么样的。</p>
<p>这里就可以引入元数据来解决这个问题，只要在定义的时候为这个类的元数据添加特殊的标记，就可以在扫描的时候识别出来。按照这个思路，我们先来实现一个装饰器标记需要注册的类，这个装饰器可以命名 Provider，代表它将会作为提供者给其他类进行消费。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// provider.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect-metadata&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CLASS_KEY = <span class="string">&quot;ioc:tagged_class&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Provider</span>(<span class="params">identifier: <span class="built_in">string</span>, args?: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Reflect</span>.defineMetadata(</span><br><span class="line">      CLASS_KEY,</span><br><span class="line">      &#123;</span><br><span class="line">        id: identifier,</span><br><span class="line">        args: args || [],</span><br><span class="line">      &#125;,</span><br><span class="line">      target</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可使用<code>Provider</code>对类 进行标记, 为了之后将其自动注册到容器中</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modB.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&quot;provider&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Provider</span>(<span class="string">&quot;b&quot;</span>, [<span class="number">10</span>])</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  p: <span class="built_in">number</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">p: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.p = p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自动注册到容器中的思路则是在启动的时候对所有文件进行扫描，获取每个文件导出的类，然后根据元数据进行绑定。简单起见，我们假设项目目录只有一级文件，实现如下:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// load.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">&quot;fs&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CLASS_KEY &#125; <span class="keyword">from</span> <span class="string">&quot;./provider&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">load</span>(<span class="params">container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// container 为全局的 IoC 容器</span></span><br><span class="line">  <span class="keyword">const</span> list = fs.readdirSync(<span class="string">&quot;./&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> file <span class="keyword">of</span> list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/\.ts$/</span>.test(file)) &#123;</span><br><span class="line">      <span class="comment">// 扫描 ts 文件</span></span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">exports</span> = <span class="built_in">require</span>(<span class="string">`./<span class="subst">$&#123;file&#125;</span>`</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> m <span class="keyword">in</span> <span class="built_in">exports</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">module</span> = <span class="built_in">exports</span>[m];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> metadata = <span class="built_in">Reflect</span>.getMetadata(CLASS_KEY, <span class="built_in">module</span>);</span><br><span class="line">          <span class="comment">// 注册实例</span></span><br><span class="line">          <span class="keyword">if</span> (metadata) &#123;</span><br><span class="line">            container.bind(metadata.id, <span class="built_in">module</span>, metadata.args);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需在项目启动时运行<code>load</code>,就可将声明时被<code>Provider</code>装饰的类,自动注册到容器中</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Container &#125; <span class="keyword">from</span> <span class="string">&quot;./container&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; load &#125; <span class="keyword">from</span> <span class="string">&quot;./load&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 IOC 容器，扫描文件</span></span><br><span class="line"><span class="keyword">const</span> container = <span class="keyword">new</span> Container();</span><br><span class="line">load(container);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(container.get(<span class="string">&quot;b&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="DI-Inject"><a href="#DI-Inject" class="headerlink" title="DI Inject"></a>DI Inject</h3><p>上文提及</p>
<blockquote>
<ul>
<li>程序启动时,所有类型会在容器中自动注册</li>
<li>实例化时类型所需的对象的自动注入, 无需在构造函数中指定</li>
</ul>
</blockquote>
<p>第一个问题解决后,再来看第二个问题,我们已经将所有需要注册的类都放入了 IoC 容器，那么，当我们需要用到某个类时，在获取这个类的实例时可以递归遍历类上的属性，并从 IoC 容器中取出相应的对象并进行赋值，即可完成依赖的注入</p>
<p>那么，又是类似的问题，如何区分哪些属性需要注入？同样，我们可以使用元数据来解决。只要定义一个装饰器，以此来标记哪些属性需要注入即可，这个装饰器命名为 <code>Inject</code>，代表该属性需要注入依赖。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inject.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect-metadata&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> PROPS_KEY = <span class="string">&quot;ioc:inject_props&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Inject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> annotationTarget = target.constructor;</span><br><span class="line">    <span class="keyword">let</span> props = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Reflect</span>.hasOwnMetadata(PROPS_KEY, annotationTarget)) &#123;</span><br><span class="line">      props = <span class="built_in">Reflect</span>.getMetadata(PROPS_KEY, annotationTarget);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    props[targetKey] = &#123;</span><br><span class="line">      value: targetKey,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Reflect</span>.defineMetadata(PROPS_KEY, props, annotationTarget);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这里我们虽然是对属性进行修饰，但实际元数据是要定义在类上，以维护该类需要注入的属性列表，因此我们必须取 <code>target.constructor</code> 作为要操作的 <code>target</code>。另外，为了方便起见，这里直接用了属性名（<code>targetKey</code>）作为从 IoC 容器中实例对应的 key。</p>
<p>然后，我们需要修改 IoC 容器的 get 方法，递归注入所有属性：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// container.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; PROPS_KEY &#125; <span class="keyword">from</span> <span class="string">&#x27;./inject&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    bindMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">bind</span>(<span class="params">identifier: <span class="built_in">string</span>, clazz: <span class="built_in">any</span>, constructorArgs?: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bindMap.set(identifier, &#123;</span><br><span class="line">            clazz,</span><br><span class="line">            <span class="title">constructorArgs</span>: <span class="title">constructorArgs</span> || []</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get&lt;T&gt;(identifier: <span class="built_in">string</span>): T &#123;</span><br><span class="line">        <span class="keyword">const</span> target = <span class="built_in">this</span>.bindMap.get(identifier);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123; clazz, <span class="title">constructorArgs</span> &#125; = <span class="title">target</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> props = <span class="built_in">Reflect</span>.getMetadata(PROPS_KEY, clazz);</span><br><span class="line">        <span class="keyword">const</span> inst = <span class="built_in">Reflect</span>.construct(clazz, <span class="title">constructorArgs</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> props) &#123;</span><br><span class="line">            <span class="keyword">const</span> identifier = props[prop].value;</span><br><span class="line">            <span class="comment">// 递归获取注入的对象</span></span><br><span class="line">            inst[ prop ] = <span class="built_in">this</span>.get(identifier);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用的时候，用 <code>Inject</code> 对属性(依赖的实例)进行装饰即可：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&#x27;provider&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Provider</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Inject</span>()</span><br><span class="line">  a: A;</span><br><span class="line">  <span class="meta">@Inject</span>()</span><br><span class="line">  b: B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终代码则有: </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; Container &#125; <span class="keyword">from</span> <span class="string">&quot;./container&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; load &#125; <span class="keyword">from</span> <span class="string">&quot;./load&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 IOC 容器，扫描文件</span></span><br><span class="line"><span class="keyword">const</span> container = <span class="keyword">new</span> Container();</span><br><span class="line">load(container);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get 时扫描元数据获取依赖的属性, 将递归注入实例对象</span></span><br><span class="line"><span class="built_in">console</span>.log(container.get(<span class="string">&quot;c&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>则可理解为 <code>Provider</code>装饰的类将自动注册到容器中, <code>Inject</code>装饰的属性 则为依赖的类的实例, 当从容器get一个类型的实例时,会将该类型所依赖实例自动注入到产出的实例中</p>
<p>文章来自:</p>
<p><a href="https://www.typescriptlang.org/docs/handbook/decorators.html#introduction">ts decorators</a></p>
<p><a href="https://juejin.cn/post/6859314697204662279">走近 MidwayJS：初识 TS 装饰器与 IoC 机制</a></p>
<p><a href="https://juejin.cn/post/6898882861277904910">如何基于 TypeScript 实现控制反转</a></p>
<p><a href="https://juejin.cn/post/6972421467552088072">Reflect Metadata(元数据)学习笔记</a></p>
<p><a href="https://github.com/rbuckton/reflect-metadata#metadata-reflection-api">metadata-reflection-api</a></p>
<p><a href="https://juejin.cn/post/6844903970289238030">有趣的装饰器：使用 Reflect Metadata 实践依赖注入</a></p>
]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
</search>
