<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>firsttime</title>
    <url>/2016/08/17/firsttime/</url>
    <content><![CDATA[<p>尝试下hexo搭博客,感觉还是github下用issue更快一点儿?嘛,用hexo倒是可以有好看的主题来用</p>
<p>博客坚持写下去的可能性对我来说还未知= =</p>
<p>有机会再体验下hexo吧</p>
<p><a href="https://github.com/5Mi/wumi_blog">github下用issue没事儿会记点儿东西</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo again</title>
    <url>/2021/04/25/hexoagain/</url>
    <content><![CDATA[<p>时隔多年再次更新下blog, 更新下主题, 想着记录点儿什么~</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次jenkins相关被挖矿处理的应对</title>
    <url>/2021/04/27/jenkins-bug/</url>
    <content><![CDATA[<h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p>事件的起源其实是上次更新blog后的疑问</p>
<blockquote>
<p>时隔多年再次更新下blog, 更新下主题, 想着记录点儿什么~</p>
</blockquote>
<p>虽说想法是好的, 但作为一个资深<code>沉默的观察员</code>的我, 自然是 <code>当我沉默着的时候,我觉得充实,我将开口,同时感到空虚</code>, 所以平时看看还好, 真要张嘴马上无话可说了, 平时没事儿就思考人生,想起自己毕业时写的一个静态页面, 那是一个介绍我当时玩的游戏的小页面, 想着正好服务器,域名都空着没用, 不妨把这个当时照着视频教程开发的小页面放上去试试, 也算纪念下回归初心</p>
<p>说干就干, 本地ssh登录服务器时却登不上, 之前可能卡了点还总断,但好歹是能登上的, 这回<code>ssh -i</code>指定密钥的情况下却仍提示输入密码, 哪怕密码正确(特意重置了😭)也不断提示重新输入密码直到<code>Permission denied</code>, 明明指定密钥不需要再输密码来着, 看来是哪里出了问题, 到控制台网页登录,发现密钥/密码都是ok的, 只好翻翻<a href="https://cloud.tencent.com/document/product/213/35574#ssh-.E9.97.AE.E9.A2.98.E5.AF.BC.E8.87.B4.E6.97.A0.E6.B3.95.E7.99.BB.E5.BD.95">文档</a>找解决方案</p>
<h3 id="应对"><a href="#应对" class="headerlink" title="应对"></a>应对</h3><p>一条条对下来发现有条对应<strong>服务器高负载</strong>相关的, 到实例监控上看, 好嘛, cpu果然已经飙到极限了</p>
<p><img src="tencentdoc.png" alt="tencentdoc"><br><img src="cloudserve.png" alt="cloudserve"></p>
<ul>
<li><p>在一通搜索下得知, 通过<code>top</code>命令查看当前cpu运行相关状态</p>
<p><img src="termial_1.png" alt="termial_1.png"></p>
</li>
<li><p>通过输入k 指定pid,我们可以直接kill掉占用cpu过高的trace进程, 但多次杀进程这个trace却总会重启, 接着我们通过<code>PID</code>来找到对应进程和所在目录, pid的查看除<code>top</code>外也可使用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef |grep [Pname 进程名]</span><br></pre></td></tr></table></figure>
<p>从上图的最后运行<code>ps -ef |grep trace</code>的返回可见到一些关键信息, 像什么<code>mine.c3pool.com</code>一看就是老矿工了, <code>2020jenkins</code>可能就是叛变革命的元凶</p>
</li>
<li><p>通过<code>PID</code>来找到对应进程和所在目录则使用, 其中 <strong>/proc目录中包含许多以数字命名的子目录，这些数字表示系统当前正在运行进程的进程号，里面包含对应进程相关的多个信息文件</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ls -l /proc/[PID]</span><br><span class="line">当然直接 <span class="built_in">cd</span> /proc/[PID] 再 ll也是一样的</span><br><span class="line">再就是</span><br><span class="line">pwdx [PID]</span><br></pre></td></tr></table></figure>
<p>当时忘了截图, 应该和以下相似, 当时的exe和pwd都指向 <code>/var/jenkins_home/XXX../trace</code>但我服务器本地是没有这个目录的<br><img src="terminal_3.png" alt="terminal"><br>考虑到我的jenkins是docker起的, 马上找到对应的挂载目录, 从<code>jenkins_home</code>一路找到这个<code>trace</code>, 但发现就算将trace删除它也马上会再自动生成😱,接下来通过<strong>jenkins</strong>作为关键字通过网络搜索果然能发现些端倪, 参考<a href="https://www.jianshu.com/p/70e071113044?from=groupmessage&isappinstalled=0">这篇</a>和<a href="https://blog.csdn.net/g6U8W7p06dCO99fQ3/article/details/90205674">这篇</a>基本上能确定我碰上的也是这种情况了,登上jenkins一看果然再一直重复跑着几个不是我建的build<br><img src="jenkins_dashbord.png" alt="jenkins_dashbord"></p>
</li>
</ul>
<p>之后处理则是按照以下顺序:</p>
<ul>
<li>禁用Jenkins task</li>
<li>升级Jenkins版本</li>
<li>检查定时任务脚本</li>
</ul>
<h3 id="升级Jenkins版本"><a href="#升级Jenkins版本" class="headerlink" title="升级Jenkins版本"></a>升级Jenkins版本</h3><p>禁用Jenkins task不必多言直接在页面上设置禁用即可, 主要是升级Jenkins版本, 页面上也有提示升级,点击却一直升级失败(可能是网络等原因,关键文件下载失败之类的,这不是很常见吗), 鉴于我的jenkins是docker跑的, 参考网上的一些文章,通过更新容器中的war包来升级jenkins:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入jenkins容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it [jenkins contanerID] sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#下载新包</span></span><br><span class="line"><span class="built_in">cd</span> /var/jenkins</span><br><span class="line">wget http://mirrors.jenkins.io/war/latest/jenkins.war</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入war包的存放路径，备份旧包，新包代替</span></span><br><span class="line">somehost$:/<span class="comment"># cd /usr/share/jenkins/</span></span><br><span class="line">somehost$:/usr/share/jenkins<span class="comment"># ls</span></span><br><span class="line">jenkins.war</span><br><span class="line"> </span><br><span class="line">somehost$:/usr/share/jenkins<span class="comment"># mv jenkins.war jenkins.war-bak</span></span><br><span class="line">somehost$:/usr/share/jenkins<span class="comment"># cp /var/jenkins_home/jenkins.war .</span></span><br><span class="line">somehost$:/usr/share/jenkins<span class="comment"># ls</span></span><br><span class="line">jenkins.war  jenkins.war-bak</span><br><span class="line"> </span><br><span class="line">somehost$:/usr/share/jenkins<span class="comment"># exit </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重启容器</span></span><br><span class="line">docker restart [jenkins contanerID]</span><br></pre></td></tr></table></figure>
<p>之后重新访问jenkins页面就会发现jenkins在准备升级,稍后就会完成升级, 升级后的jenkins则会提示<a href="https://wiki.jenkins.io/display/JENKINS/Security+implication+of+building+on+master">已有风险</a><br><img src="jenkins_doc_security.png" alt="jenkins_doc_security"><br>看起来好像说的是通过jenkins controller直接运行的build能直接读写<code>$JENKINS_HOME</code>的文件,相当于能触及像安装插件,读凭证,创建新job等几乎所有操作了, 所以貌似是建议通过其他服务器,来代理跑构建任务(<code>agent</code>), 否则的话就要好好检查下<code>$JENKINS_HOME</code>的权限了, jenkins我暂时用不上,先按上面设置把执行器改成零<br><img src="jenkins_node.png" alt="jenkins_node"></p>
<h3 id="检查定时任务脚本"><a href="#检查定时任务脚本" class="headerlink" title="检查定时任务脚本"></a>检查定时任务脚本</h3><p>接下来再检查下服务器在跑啥定时脚本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">crontab -l <span class="comment"># 查看</span></span><br><span class="line">crontab -r <span class="comment"># 清空</span></span><br></pre></td></tr></table></figure>
<p><img src="terminal_4.png" alt="terminal_4"></p>
<p>确实发现了个我毫无印象的脚本, 也没多想,直接被我<code>crontab -r</code>了, 一套操作下来<code>top</code>命令查看后, cpu使用已然恢复正常(服务器更本没跑啥,占用率趋近于0了), 罪魁祸首trace也不再复活, 也算是「一件落着/いっけんらくちゃく」</p>
<h3 id="终局"><a href="#终局" class="headerlink" title="终局"></a>终局</h3><p>解决后回到本地ssh登录服务器,发现仍是</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">root@xxx.xx.xx.xxx<span class="string">&#x27;s password: </span></span><br><span class="line"><span class="string">Permission denied, please try again.</span></span><br><span class="line"><span class="string">root@xxx.xx.xx.xxx&#x27;</span>s password: </span><br><span class="line">root@xxx.xx.xx.xxx: Permission denied (publickey,gssapi-keyex,gssapi-with-mic,pa</span><br><span class="line">ssword)</span><br></pre></td></tr></table></figure>
<p>fuck sake,这就太令人奇怪啦,参考网上修改 <code>/etc/ssh/ssh_config</code> 开启密码验证, root用户登录等选项重启ssh服务啥的都试了一遍, 还是不管用, 最后的最后发现从最开始本地登录时的公网ip就打错了一位, 真的是知道结局的我眼泪落下来, 残念</p>
<h3 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h3><p>登录上服务器就好说了, 把之前的静态文件上传上去就好, 看着自己最最开始写的页面真是感慨万千, 仿佛当时的情感又涌上心头, 可现在的自己又有多少成长呢, 是否又失去了大把可能性, 变得越来越无趣了呢. </p>
<p>ps. 服务器域名估计今年中旬就到期了,姑且先放着几天吧, <a href="https://www.mimimimimi.top/">www.mimimimimi.top</a>, 这游戏是我大学要毕业时玩儿的, 当时记得通关一周目普通模式死了300多次, 像素游戏小而精美,很有旺达与巨像的味道, 那几天下来脑袋里都是这款游戏, 哈哈, 毕设要写啥,舍友们都在发愁, 我想着要不然就写个介绍这个游戏的”小网站”吧, 这么多年后它终于被我再次想起,成功上线了😏 </p>
]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>ssh</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用fabric完成多边形选区</title>
    <url>/2021/05/06/%E4%BD%BF%E7%94%A8fabric%E5%AE%8C%E6%88%90%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%80%89%E5%8C%BA/</url>
    <content><![CDATA[<p><img src="draw.gif" alt="a"></p>
<p>之前有过这么个需求, 说是要在图片中选区(车站,广场等),然后选区的要求是<strong>不规则凸多边形</strong> <strong>按点连接</strong>, 之后要获取选区点坐标, 同时也有将生成点坐标回显展示选区的需求, 在一番调研之后决定使用<a href="http://fabricjs.com/">fabric.js</a>来实现功能</p>
<blockquote>
<p>Fabric是一个强大而简单的JS Canvas库，我们能通过使用它实现在Canvas上创建、填充图形、给图形填充渐变颜色。 组合图形（包括组合图形、图形文字、图片等）等一系列功能。简单来说我们可以通过使用Fabric从而以较为简单的方式实现较为复杂的Canvas功能</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>整个的思路大概是先初始化fabric实例,将图片展示到canvas上,根据图片和canvas的尺寸得到缩放比例,方便将后续得到的点坐标按图片尺寸还原.接着通过鼠标点击在canvas上绘制点,将点按照点击顺序连接成线,则得到多边形的边,此时三个点以上则可连接成多边形,当点击完成时将<strong>起始点</strong>与<strong>终点</strong>连接闭合成多边形.</p>
<p><img src="draw-close.png" alt="draw-close"></p>
<p>其中核心的问题则是按顺序连接的点,当图形完成,起始点和终点连接时,选区图形是否能成为一个多边形?此处我采用的方式是, 通过鼠标移动,可以落点时鼠标同首尾点连接虚线,当无法绘制所需多边形时隐藏虚线并<strong>无法落点</strong>,确保已经绘制的点之间可连成多边形</p>
<p><img src="draw-cross.png" alt="draw-cross"></p>
<p>即核心的判断则是:</p>
<ul>
<li>起始点与鼠标连线:line1,终点与鼠标连线:line2,则line1,line2是否<strong>同时</strong>与已连接的线段<strong>相交</strong>, 同时相交则无法落点<br><img src="draw2.png" alt="draw2"></li>
<li><strong>已连接线段中除首尾两条外</strong>, 是否存在line1<strong>或</strong>line2与某条线段相交, 相交则无法落点<br><img src="draw3.png" alt="draw3"></li>
<li>通过向量叉乘判断线段相交<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算向量叉乘</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">crossMul</span>(<span class="params">v1, v2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v1.x * v2.y - v1.y * v2.x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断两条线段是否相交line1(p1,p2) line2(p3,p4)</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">checkCross</span>(<span class="params">p1, p2, p3, p4</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> v1 = &#123; <span class="attr">x</span>: p1.x - p3.x, <span class="attr">y</span>: p1.y - p3.y &#125;,</span><br><span class="line">      v2 = &#123; <span class="attr">x</span>: p2.x - p3.x, <span class="attr">y</span>: p2.y - p3.y &#125;,</span><br><span class="line">      v3 = &#123; <span class="attr">x</span>: p4.x - p3.x, <span class="attr">y</span>: p4.y - p3.y &#125;,</span><br><span class="line">      v = crossMul(v1, v3) * crossMul(v2, v3);</span><br><span class="line">    v1 = &#123; <span class="attr">x</span>: p3.x - p1.x, <span class="attr">y</span>: p3.y - p1.y &#125;;</span><br><span class="line">    v2 = &#123; <span class="attr">x</span>: p4.x - p1.x, <span class="attr">y</span>: p4.y - p1.y &#125;;</span><br><span class="line">    v3 = &#123; <span class="attr">x</span>: p2.x - p1.x, <span class="attr">y</span>: p2.y - p1.y &#125;;</span><br><span class="line">    <span class="keyword">return</span> v &lt;= <span class="number">0</span> &amp;&amp; crossMul(v1, v3) * crossMul(v2, v3) &lt;= <span class="number">0</span></span><br><span class="line">      ? <span class="literal">true</span></span><br><span class="line">      : <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>首先页面上要有个canvas容器,据此生成fabric的canvas实例,还要将图片展示在canvas中,然后根据图片尺寸,canvas尺寸得到展示的缩放比例<code>radio</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> convasDefaultWidth = <span class="number">500</span>;</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="keyword">var</span> image = <span class="keyword">new</span> fabric.Image(<span class="built_in">document</span>.getElementById(<span class="string">&quot;image&quot;</span>));</span><br><span class="line">      <span class="keyword">var</span> imageWidth = image.get(<span class="string">&quot;width&quot;</span>);</span><br><span class="line">      <span class="keyword">var</span> canvasWidth =</span><br><span class="line">        imageWidth &gt; convasDefaultWidth ? convasDefaultWidth : imageWidth;</span><br><span class="line">      <span class="comment">// 缩放比例</span></span><br><span class="line">      <span class="keyword">var</span> radio = imageWidth / canvasWidth;</span><br><span class="line">      <span class="comment">// fabfric实例</span></span><br><span class="line">      <span class="keyword">var</span> canvas = <span class="keyword">new</span> fabric.Canvas(<span class="string">&quot;canvas&quot;</span>, &#123;</span><br><span class="line">        width: canvasWidth,</span><br><span class="line">        height: image.get(<span class="string">&quot;height&quot;</span>) / radio,</span><br><span class="line">        backgroundImage: image.scaleToWidth(canvasWidth),</span><br><span class="line">        backgroundColor: <span class="string">&#x27;transparent&#x27;</span>,</span><br><span class="line">        selection:<span class="literal">false</span></span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>
<p>当绘制完成或回显时, 直接使用fabric绘制多边形即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> polygon = <span class="keyword">new</span> fabric.Polygon([], &#123;</span><br><span class="line">        strokeWidth: <span class="number">2</span>,</span><br><span class="line">        stroke: <span class="string">&quot;green&quot;</span>,</span><br><span class="line">        fill: <span class="string">&quot;transparent&quot;</span>,</span><br><span class="line">        objectCaching: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// transparentCorners: false,</span></span><br><span class="line">        <span class="comment">// cornerColor: &quot;blue&quot;,</span></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 添加到画布</span></span><br><span class="line">      canvas.add(polygon);</span><br></pre></td></tr></table></figure>
<p>初始化各个状态,以及将来鼠标显示的连接线等</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 已绘制点</span></span><br><span class="line"><span class="keyword">var</span> points = [];</span><br><span class="line"><span class="comment">// 当前是否可以落点</span></span><br><span class="line"><span class="keyword">var</span> canAddPoint = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 已存在线段</span></span><br><span class="line"><span class="keyword">var</span> existLines = [];</span><br><span class="line"><span class="comment">// 绘制是否完成</span></span><br><span class="line"><span class="keyword">var</span> isCompelete = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 线段默认配置</span></span><br><span class="line"><span class="keyword">var</span> lineOption = &#123;</span><br><span class="line">  strokeWidth: <span class="number">2</span>,</span><br><span class="line">  stroke: <span class="string">&quot;green&quot;</span>,</span><br><span class="line">  fill: <span class="string">&quot;green&quot;</span>,</span><br><span class="line">  selectable: <span class="literal">false</span>,</span><br><span class="line">  evented: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 连接线使用虚线</span></span><br><span class="line"><span class="keyword">var</span> dashLineOption = <span class="built_in">Object</span>.assign(&#123;&#125;,lineOption,&#123;<span class="attr">strokeDashArray</span>: [<span class="number">10</span>, <span class="number">15</span>]&#125;)</span><br><span class="line"><span class="comment">// 鼠标连接线</span></span><br><span class="line"><span class="keyword">var</span> combineLineWithFirst = <span class="keyword">new</span> fabric.Line([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], dashLineOption);</span><br><span class="line"><span class="keyword">var</span> combineLineWithSecond = <span class="keyword">new</span> fabric.Line([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], dashLineOption);</span><br><span class="line"><span class="comment">// 添加至canvas</span></span><br><span class="line">canvas.add(combineLineWithFirst);</span><br><span class="line">canvas.add(combineLineWithSecond);</span><br></pre></td></tr></table></figure>
<p>初始化fabric canvas的鼠标事件,即鼠标移动和点击</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移动</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canvasHandleMouseMove</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pointsLen = points.length;</span><br><span class="line">  <span class="keyword">if</span> (pointsLen === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 起点与终点</span></span><br><span class="line">  <span class="keyword">var</span> firstPoint = points[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> lastPoint = points[pointsLen - <span class="number">1</span>];</span><br><span class="line">  <span class="comment">// 两点以上</span></span><br><span class="line">  <span class="keyword">if</span> (pointsLen &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 已绘制的线段</span></span><br><span class="line">    <span class="keyword">var</span> exlines = getLinesArr();</span><br><span class="line">    <span class="keyword">var</span> hasCross = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; exlines.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> perline = exlines[i];</span><br><span class="line">      <span class="keyword">var</span> point1 = &#123; <span class="attr">x</span>: perline[<span class="number">0</span>], <span class="attr">y</span>: perline[<span class="number">1</span>] &#125;;</span><br><span class="line">      <span class="keyword">var</span> point2 = &#123; <span class="attr">x</span>: perline[<span class="number">2</span>], <span class="attr">y</span>: perline[<span class="number">3</span>] &#125;;</span><br><span class="line">      <span class="comment">// 根据之前所说的判断条件</span></span><br><span class="line">      <span class="comment">// line1,line2是否同时与已连接的线段相交</span></span><br><span class="line">      <span class="comment">// 或 存在line1或line2与某条线段相交</span></span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        checkCross(options.pointer, firstPoint, point1, point2) &amp;&amp;</span><br><span class="line">        checkCross(options.pointer, lastPoint, point1, point2)</span><br><span class="line">      ) &#123;</span><br><span class="line">        hasCross = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i &lt; exlines.length - <span class="number">1</span> &amp;&amp; (checkCross(options.pointer, firstPoint, point1, point2) ||</span><br><span class="line">      checkCross(options.pointer, lastPoint, point1, point2)))&#123;</span><br><span class="line">        hasCross = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 能落点, 绘制鼠标连接线</span></span><br><span class="line">  <span class="keyword">if</span> (!hasCross) &#123;</span><br><span class="line">    canAddPoint = <span class="literal">true</span>;</span><br><span class="line">    setLineWithPoint(combineLineWithFirst, options.pointer, firstPoint);</span><br><span class="line">    setLineWithPoint(combineLineWithSecond, options.pointer, lastPoint);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 隐藏鼠标连接线</span></span><br><span class="line">    canAddPoint = <span class="literal">false</span>;</span><br><span class="line">    setLineWithPoint(combineLineWithFirst);</span><br><span class="line">    setLineWithPoint(combineLineWithSecond);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// fabric 绘制</span></span><br><span class="line">  canvas.renderAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点击</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canvasHandleMouseDown</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!canAddPoint) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">var</span> pointsLen = points.length;</span><br><span class="line">        <span class="keyword">var</span> lastPoint = points[pointsLen - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          lastPoint &amp;&amp;</span><br><span class="line">          options.pointer.x === lastPoint.x &amp;&amp;</span><br><span class="line">          options.pointer.y === lastPoint.y</span><br><span class="line">        )</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// console.log(options, options.pointer.x, options.pointer.y);</span></span><br><span class="line">        <span class="comment">// 落点, 注意精度</span></span><br><span class="line">        points.push(&#123;</span><br><span class="line">          x: +options.pointer.x.toFixed(<span class="number">3</span>),</span><br><span class="line">          y: +options.pointer.y.toFixed(<span class="number">3</span>),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 落点连接线段</span></span><br><span class="line">        <span class="keyword">if</span> (lastPoint) &#123;</span><br><span class="line">          <span class="keyword">var</span> line = <span class="keyword">new</span> fabric.Line(</span><br><span class="line">            [lastPoint.x, lastPoint.y, options.pointer.x, options.pointer.y],</span><br><span class="line">            lineOption</span><br><span class="line">          );</span><br><span class="line">          canvas.add(line);</span><br><span class="line">          existLines.push(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        canvas.requestRenderAll();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>当绘制完成或回显时则将鼠标连接线隐藏, 切换完成状态, 通过已绘制的点连接生成多边形,而重置则清空画布并重置状态即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多边形回显</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">drowPolygon</span>(<span class="params">points</span>) </span>&#123;</span><br><span class="line">        isCompelete = <span class="literal">true</span>;</span><br><span class="line">        polygon.set(<span class="string">&quot;points&quot;</span>, points);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>后续再优化的话 其实可以开放fabric多边形的锚点拖拽,旋转,形变等等</p>
<p><a href="https://gitee.com/workthing/canvas_polycon">demo完整代码</a></p>
]]></content>
      <categories>
        <category>技术相关</category>
      </categories>
      <tags>
        <tag>工作中</tag>
      </tags>
  </entry>
</search>
